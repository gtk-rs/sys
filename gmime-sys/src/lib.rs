// This file was generated by gir (https://github.com/gtk-rs/gir @ 6704a1c)
// from gir-files (https://github.com/gtk-rs/gir-files @ 33386b3+)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gio_sys as gio;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

// Enums
pub type GMimeAddressType = c_int;
pub const GMIME_ADDRESS_TYPE_SENDER: GMimeAddressType = 0;
pub const GMIME_ADDRESS_TYPE_FROM: GMimeAddressType = 1;
pub const GMIME_ADDRESS_TYPE_REPLY_TO: GMimeAddressType = 2;
pub const GMIME_ADDRESS_TYPE_TO: GMimeAddressType = 3;
pub const GMIME_ADDRESS_TYPE_CC: GMimeAddressType = 4;
pub const GMIME_ADDRESS_TYPE_BCC: GMimeAddressType = 5;

pub type GMimeAutocryptPreferEncrypt = c_int;
pub const GMIME_AUTOCRYPT_PREFER_ENCRYPT_NONE: GMimeAutocryptPreferEncrypt = 0;
pub const GMIME_AUTOCRYPT_PREFER_ENCRYPT_MUTUAL: GMimeAutocryptPreferEncrypt = 1;

pub type GMimeCipherAlgo = c_int;
pub const GMIME_CIPHER_ALGO_DEFAULT: GMimeCipherAlgo = 0;
pub const GMIME_CIPHER_ALGO_IDEA: GMimeCipherAlgo = 1;
pub const GMIME_CIPHER_ALGO_3DES: GMimeCipherAlgo = 2;
pub const GMIME_CIPHER_ALGO_CAST5: GMimeCipherAlgo = 3;
pub const GMIME_CIPHER_ALGO_BLOWFISH: GMimeCipherAlgo = 4;
pub const GMIME_CIPHER_ALGO_AES: GMimeCipherAlgo = 7;
pub const GMIME_CIPHER_ALGO_AES192: GMimeCipherAlgo = 8;
pub const GMIME_CIPHER_ALGO_AES256: GMimeCipherAlgo = 9;
pub const GMIME_CIPHER_ALGO_TWOFISH: GMimeCipherAlgo = 10;
pub const GMIME_CIPHER_ALGO_CAMELLIA128: GMimeCipherAlgo = 11;
pub const GMIME_CIPHER_ALGO_CAMELLIA192: GMimeCipherAlgo = 12;
pub const GMIME_CIPHER_ALGO_CAMELLIA256: GMimeCipherAlgo = 13;

pub type GMimeContentEncoding = c_int;
pub const GMIME_CONTENT_ENCODING_DEFAULT: GMimeContentEncoding = 0;
pub const GMIME_CONTENT_ENCODING_7BIT: GMimeContentEncoding = 1;
pub const GMIME_CONTENT_ENCODING_8BIT: GMimeContentEncoding = 2;
pub const GMIME_CONTENT_ENCODING_BINARY: GMimeContentEncoding = 3;
pub const GMIME_CONTENT_ENCODING_BASE64: GMimeContentEncoding = 4;
pub const GMIME_CONTENT_ENCODING_QUOTEDPRINTABLE: GMimeContentEncoding = 5;
pub const GMIME_CONTENT_ENCODING_UUENCODE: GMimeContentEncoding = 6;

pub type GMimeDigestAlgo = c_int;
pub const GMIME_DIGEST_ALGO_DEFAULT: GMimeDigestAlgo = 0;
pub const GMIME_DIGEST_ALGO_MD5: GMimeDigestAlgo = 1;
pub const GMIME_DIGEST_ALGO_SHA1: GMimeDigestAlgo = 2;
pub const GMIME_DIGEST_ALGO_RIPEMD160: GMimeDigestAlgo = 3;
pub const GMIME_DIGEST_ALGO_MD2: GMimeDigestAlgo = 5;
pub const GMIME_DIGEST_ALGO_TIGER192: GMimeDigestAlgo = 6;
pub const GMIME_DIGEST_ALGO_HAVAL5160: GMimeDigestAlgo = 7;
pub const GMIME_DIGEST_ALGO_SHA256: GMimeDigestAlgo = 8;
pub const GMIME_DIGEST_ALGO_SHA384: GMimeDigestAlgo = 9;
pub const GMIME_DIGEST_ALGO_SHA512: GMimeDigestAlgo = 10;
pub const GMIME_DIGEST_ALGO_SHA224: GMimeDigestAlgo = 11;
pub const GMIME_DIGEST_ALGO_MD4: GMimeDigestAlgo = 301;
pub const GMIME_DIGEST_ALGO_CRC32: GMimeDigestAlgo = 302;
pub const GMIME_DIGEST_ALGO_CRC32_RFC1510: GMimeDigestAlgo = 303;
pub const GMIME_DIGEST_ALGO_CRC32_RFC2440: GMimeDigestAlgo = 304;

pub type GMimeEncodingConstraint = c_int;
pub const GMIME_ENCODING_CONSTRAINT_7BIT: GMimeEncodingConstraint = 0;
pub const GMIME_ENCODING_CONSTRAINT_8BIT: GMimeEncodingConstraint = 1;
pub const GMIME_ENCODING_CONSTRAINT_BINARY: GMimeEncodingConstraint = 2;

pub type GMimeEncryptFlags = c_int;
pub const GMIME_ENCRYPT_NONE: GMimeEncryptFlags = 0;
pub const GMIME_ENCRYPT_ALWAYS_TRUST: GMimeEncryptFlags = 1;
pub const GMIME_ENCRYPT_NO_COMPRESS: GMimeEncryptFlags = 16;
pub const GMIME_ENCRYPT_SYMMETRIC: GMimeEncryptFlags = 32;
pub const GMIME_ENCRYPT_THROW_KEYIDS: GMimeEncryptFlags = 64;

pub type GMimeFilterFromMode = c_int;
pub const GMIME_FILTER_FROM_MODE_DEFAULT: GMimeFilterFromMode = 0;
pub const GMIME_FILTER_FROM_MODE_ARMOR: GMimeFilterFromMode = 1;

pub type GMimeFilterGZipMode = c_int;
pub const GMIME_FILTER_GZIP_MODE_ZIP: GMimeFilterGZipMode = 0;
pub const GMIME_FILTER_GZIP_MODE_UNZIP: GMimeFilterGZipMode = 1;

pub type GMimeFormat = c_int;
pub const GMIME_FORMAT_MESSAGE: GMimeFormat = 0;
pub const GMIME_FORMAT_MBOX: GMimeFormat = 1;
pub const GMIME_FORMAT_MMDF: GMimeFormat = 2;

pub type GMimeNewLineFormat = c_int;
pub const GMIME_NEWLINE_FORMAT_UNIX: GMimeNewLineFormat = 0;
pub const GMIME_NEWLINE_FORMAT_DOS: GMimeNewLineFormat = 1;

pub type GMimeOpenPGPData = c_int;
pub const GMIME_OPENPGP_DATA_NONE: GMimeOpenPGPData = 0;
pub const GMIME_OPENPGP_DATA_ENCRYPTED: GMimeOpenPGPData = 1;
pub const GMIME_OPENPGP_DATA_SIGNED: GMimeOpenPGPData = 2;
pub const GMIME_OPENPGP_DATA_PUBLIC_KEY: GMimeOpenPGPData = 3;
pub const GMIME_OPENPGP_DATA_PRIVATE_KEY: GMimeOpenPGPData = 4;

pub type GMimeParamEncodingMethod = c_int;
pub const GMIME_PARAM_ENCODING_METHOD_DEFAULT: GMimeParamEncodingMethod = 0;
pub const GMIME_PARAM_ENCODING_METHOD_RFC2231: GMimeParamEncodingMethod = 1;
pub const GMIME_PARAM_ENCODING_METHOD_RFC2047: GMimeParamEncodingMethod = 2;

pub type GMimeParserWarning = c_int;
pub const GMIME_WARN_DUPLICATED_CONTENT_HDR: GMimeParserWarning = 1;
pub const GMIME_WARN_DUPLICATED_PARAMETER: GMimeParserWarning = 2;
pub const GMIME_WARN_UNENCODED_8BIT_HEADER: GMimeParserWarning = 3;
pub const GMIME_WARN_INVALID_CONTENT_TYPE: GMimeParserWarning = 4;
pub const GMIME_WARN_INVALID_HEADER: GMimeParserWarning = 5;
pub const GMIME_WARN_MALFORMED_MULTIPART: GMimeParserWarning = 6;
pub const GMIME_WARN_TRUNCATED_MESSAGE: GMimeParserWarning = 7;
pub const GMIME_WARN_MALFORMED_MESSAGE: GMimeParserWarning = 8;
pub const GMIME_CRIT_CONFLICTING_CONTENT_HDR: GMimeParserWarning = 9;
pub const GMIME_CRIT_CONFLICTING_PARAMETER: GMimeParserWarning = 10;
pub const GMIME_CRIT_MULTIPART_WITHOUT_BOUNDARY: GMimeParserWarning = 11;

pub type GMimePubKeyAlgo = c_int;
pub const GMIME_PUBKEY_ALGO_DEFAULT: GMimePubKeyAlgo = 0;
pub const GMIME_PUBKEY_ALGO_RSA: GMimePubKeyAlgo = 1;
pub const GMIME_PUBKEY_ALGO_RSA_E: GMimePubKeyAlgo = 2;
pub const GMIME_PUBKEY_ALGO_RSA_S: GMimePubKeyAlgo = 3;
pub const GMIME_PUBKEY_ALGO_ELG_E: GMimePubKeyAlgo = 16;
pub const GMIME_PUBKEY_ALGO_DSA: GMimePubKeyAlgo = 17;
pub const GMIME_PUBKEY_ALGO_ECC: GMimePubKeyAlgo = 18;
pub const GMIME_PUBKEY_ALGO_ELG: GMimePubKeyAlgo = 20;
pub const GMIME_PUBKEY_ALGO_ECDSA: GMimePubKeyAlgo = 301;
pub const GMIME_PUBKEY_ALGO_ECDH: GMimePubKeyAlgo = 302;
pub const GMIME_PUBKEY_ALGO_EDDSA: GMimePubKeyAlgo = 303;

pub type GMimeRfcComplianceMode = c_int;
pub const GMIME_RFC_COMPLIANCE_LOOSE: GMimeRfcComplianceMode = 0;
pub const GMIME_RFC_COMPLIANCE_STRICT: GMimeRfcComplianceMode = 1;

pub type GMimeSecureMimeType = c_int;
pub const GMIME_SECURE_MIME_TYPE_COMPRESSED_DATA: GMimeSecureMimeType = 0;
pub const GMIME_SECURE_MIME_TYPE_ENVELOPED_DATA: GMimeSecureMimeType = 1;
pub const GMIME_SECURE_MIME_TYPE_SIGNED_DATA: GMimeSecureMimeType = 2;
pub const GMIME_SECURE_MIME_TYPE_CERTS_ONLY: GMimeSecureMimeType = 3;
pub const GMIME_SECURE_MIME_TYPE_UNKNOWN: GMimeSecureMimeType = 4;

pub type GMimeSeekWhence = c_int;
pub const GMIME_STREAM_SEEK_SET: GMimeSeekWhence = 0;
pub const GMIME_STREAM_SEEK_CUR: GMimeSeekWhence = 1;
pub const GMIME_STREAM_SEEK_END: GMimeSeekWhence = 2;

pub type GMimeSignatureStatus = c_int;
pub const GMIME_SIGNATURE_STATUS_VALID: GMimeSignatureStatus = 1;
pub const GMIME_SIGNATURE_STATUS_GREEN: GMimeSignatureStatus = 2;
pub const GMIME_SIGNATURE_STATUS_RED: GMimeSignatureStatus = 4;
pub const GMIME_SIGNATURE_STATUS_KEY_REVOKED: GMimeSignatureStatus = 16;
pub const GMIME_SIGNATURE_STATUS_KEY_EXPIRED: GMimeSignatureStatus = 32;
pub const GMIME_SIGNATURE_STATUS_SIG_EXPIRED: GMimeSignatureStatus = 64;
pub const GMIME_SIGNATURE_STATUS_KEY_MISSING: GMimeSignatureStatus = 128;
pub const GMIME_SIGNATURE_STATUS_CRL_MISSING: GMimeSignatureStatus = 256;
pub const GMIME_SIGNATURE_STATUS_CRL_TOO_OLD: GMimeSignatureStatus = 512;
pub const GMIME_SIGNATURE_STATUS_BAD_POLICY: GMimeSignatureStatus = 1024;
pub const GMIME_SIGNATURE_STATUS_SYS_ERROR: GMimeSignatureStatus = 2048;
pub const GMIME_SIGNATURE_STATUS_TOFU_CONFLICT: GMimeSignatureStatus = 4096;

pub type GMimeStreamBufferMode = c_int;
pub const GMIME_STREAM_BUFFER_BLOCK_READ: GMimeStreamBufferMode = 0;
pub const GMIME_STREAM_BUFFER_BLOCK_WRITE: GMimeStreamBufferMode = 1;

pub type GMimeTrust = c_int;
pub const GMIME_TRUST_UNKNOWN: GMimeTrust = 0;
pub const GMIME_TRUST_UNDEFINED: GMimeTrust = 1;
pub const GMIME_TRUST_NEVER: GMimeTrust = 2;
pub const GMIME_TRUST_MARGINAL: GMimeTrust = 3;
pub const GMIME_TRUST_FULL: GMimeTrust = 4;
pub const GMIME_TRUST_ULTIMATE: GMimeTrust = 5;

pub type GMimeValidity = c_int;
pub const GMIME_VALIDITY_UNKNOWN: GMimeValidity = 0;
pub const GMIME_VALIDITY_UNDEFINED: GMimeValidity = 1;
pub const GMIME_VALIDITY_NEVER: GMimeValidity = 2;
pub const GMIME_VALIDITY_MARGINAL: GMimeValidity = 3;
pub const GMIME_VALIDITY_FULL: GMimeValidity = 4;
pub const GMIME_VALIDITY_ULTIMATE: GMimeValidity = 5;

pub type VerifyFlags = c_int;
pub const GMIME_VERIFY_NONE: VerifyFlags = 0;
pub type GMimeVerifyFlags = VerifyFlags;

// Constants
pub const GMIME_BINARY_AGE: c_int = 200;
pub const GMIME_DISPOSITION_ATTACHMENT: *const c_char = b"attachment\0" as *const u8 as *const c_char;
pub const GMIME_DISPOSITION_INLINE: *const c_char = b"inline\0" as *const u8 as *const c_char;
pub const GMIME_FILTER_ENRICHED_IS_RICHTEXT: c_int = 1;
pub const GMIME_FILTER_HTML_BLOCKQUOTE_CITATION: c_int = 256;
pub const GMIME_FILTER_HTML_CITE: c_int = 128;
pub const GMIME_FILTER_HTML_CONVERT_ADDRESSES: c_int = 32;
pub const GMIME_FILTER_HTML_CONVERT_NL: c_int = 2;
pub const GMIME_FILTER_HTML_CONVERT_SPACES: c_int = 4;
pub const GMIME_FILTER_HTML_CONVERT_URLS: c_int = 8;
pub const GMIME_FILTER_HTML_ESCAPE_8BIT: c_int = 64;
pub const GMIME_FILTER_HTML_MARK_CITATION: c_int = 16;
pub const GMIME_FILTER_HTML_PRE: c_int = 1;
pub const GMIME_INTERFACE_AGE: c_int = 0;
pub const GMIME_MAJOR_VERSION: c_int = 3;
pub const GMIME_MICRO_VERSION: c_int = 0;
pub const GMIME_MINOR_VERSION: c_int = 2;
pub const GMIME_SIGNATURE_STATUS_ERROR_MASK: c_int = -1;
pub const GMIME_UUDECODE_STATE_BEGIN: c_int = 65536;
pub const GMIME_UUDECODE_STATE_END: c_int = 131072;
pub const GMIME_UUDECODE_STATE_INIT: c_int = 0;
pub const GMIME_UUDECODE_STATE_MASK: c_int = 0;
pub const GMIME_YDECODE_STATE_BEGIN: c_int = 4096;
pub const GMIME_YDECODE_STATE_DECODE: c_int = 16384;
pub const GMIME_YDECODE_STATE_END: c_int = 32768;
pub const GMIME_YDECODE_STATE_EOLN: c_int = 256;
pub const GMIME_YDECODE_STATE_ESCAPE: c_int = 512;
pub const GMIME_YDECODE_STATE_INIT: c_int = 0;
pub const GMIME_YDECODE_STATE_PART: c_int = 8192;
pub const GMIME_YENCODE_CRC_INIT: c_int = -1;
pub const GMIME_YENCODE_STATE_INIT: c_int = 0;

// Flags
bitflags! {
    #[repr(C)]
    pub struct GMimeDecryptFlags: c_uint {
        const NONE = 0;
        const EXPORT_SESSION_KEY = 1;
    }
}
pub const GMIME_DECRYPT_NONE: GMimeDecryptFlags = GMimeDecryptFlags::NONE;
pub const GMIME_DECRYPT_EXPORT_SESSION_KEY: GMimeDecryptFlags = GMimeDecryptFlags::EXPORT_SESSION_KEY;

bitflags! {
    #[repr(C)]
    pub struct GMimeFilterBestFlags: c_uint {
        const CHARSET = 1;
        const ENCODING = 2;
    }
}
pub const GMIME_FILTER_BEST_CHARSET: GMimeFilterBestFlags = GMimeFilterBestFlags::CHARSET;
pub const GMIME_FILTER_BEST_ENCODING: GMimeFilterBestFlags = GMimeFilterBestFlags::ENCODING;

bitflags! {
    #[repr(C)]
    pub struct GMimeOpenPGPState: c_uint {
        const NONE = 0;
        const BEGIN_PGP_MESSAGE = 1;
        const END_PGP_MESSAGE = 3;
        const BEGIN_PGP_SIGNED_MESSAGE = 4;
        const BEGIN_PGP_SIGNATURE = 12;
        const END_PGP_SIGNATURE = 28;
        const BEGIN_PGP_PUBLIC_KEY_BLOCK = 32;
        const END_PGP_PUBLIC_KEY_BLOCK = 96;
        const BEGIN_PGP_PRIVATE_KEY_BLOCK = 128;
        const END_PGP_PRIVATE_KEY_BLOCK = 384;
    }
}
pub const GMIME_OPENPGP_NONE: GMimeOpenPGPState = GMimeOpenPGPState::NONE;
pub const GMIME_OPENPGP_BEGIN_PGP_MESSAGE: GMimeOpenPGPState = GMimeOpenPGPState::BEGIN_PGP_MESSAGE;
pub const GMIME_OPENPGP_END_PGP_MESSAGE: GMimeOpenPGPState = GMimeOpenPGPState::END_PGP_MESSAGE;
pub const GMIME_OPENPGP_BEGIN_PGP_SIGNED_MESSAGE: GMimeOpenPGPState = GMimeOpenPGPState::BEGIN_PGP_SIGNED_MESSAGE;
pub const GMIME_OPENPGP_BEGIN_PGP_SIGNATURE: GMimeOpenPGPState = GMimeOpenPGPState::BEGIN_PGP_SIGNATURE;
pub const GMIME_OPENPGP_END_PGP_SIGNATURE: GMimeOpenPGPState = GMimeOpenPGPState::END_PGP_SIGNATURE;
pub const GMIME_OPENPGP_BEGIN_PGP_PUBLIC_KEY_BLOCK: GMimeOpenPGPState = GMimeOpenPGPState::BEGIN_PGP_PUBLIC_KEY_BLOCK;
pub const GMIME_OPENPGP_END_PGP_PUBLIC_KEY_BLOCK: GMimeOpenPGPState = GMimeOpenPGPState::END_PGP_PUBLIC_KEY_BLOCK;
pub const GMIME_OPENPGP_BEGIN_PGP_PRIVATE_KEY_BLOCK: GMimeOpenPGPState = GMimeOpenPGPState::BEGIN_PGP_PRIVATE_KEY_BLOCK;
pub const GMIME_OPENPGP_END_PGP_PRIVATE_KEY_BLOCK: GMimeOpenPGPState = GMimeOpenPGPState::END_PGP_PRIVATE_KEY_BLOCK;

// Callbacks
pub type GMimeCryptoContextNewFunc = Option<unsafe extern "C" fn() -> *mut GMimeCryptoContext>;
pub type GMimeHeaderRawValueFormatter = Option<unsafe extern "C" fn(*mut GMimeHeader, *mut GMimeFormatOptions, *const c_char, *const c_char) -> *mut c_char>;
pub type GMimeObjectForeachFunc = Option<unsafe extern "C" fn(*mut GMimeObject, *mut GMimeObject, gpointer)>;
pub type GMimeParserHeaderRegexFunc = Option<unsafe extern "C" fn(*mut GMimeParser, *const c_char, *const c_char, i64, gpointer)>;
pub type GMimeParserWarningFunc = Option<unsafe extern "C" fn(i64, GMimeParserWarning, *const c_char, gpointer)>;
pub type GMimePasswordRequestFunc = Option<unsafe extern "C" fn(*mut GMimeCryptoContext, *const c_char, *const c_char, gboolean, *mut GMimeStream, *mut *mut glib::GError) -> gboolean>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeApplicationPkcs7MimeClass {
    pub parent_class: GMimePartClass,
}

impl ::std::fmt::Debug for GMimeApplicationPkcs7MimeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeApplicationPkcs7MimeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeAutocryptHeaderClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeAutocryptHeaderClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeAutocryptHeaderClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeAutocryptHeaderListClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeAutocryptHeaderListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeAutocryptHeaderListClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeCertificateClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeCertificateClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeCertificateClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeCertificateListClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeCertificateListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeCertificateListClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeCharset {
    pub mask: c_uint,
    pub level: c_uint,
}

impl ::std::fmt::Debug for GMimeCharset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeCharset @ {:?}", self as *const _))
         .field("mask", &self.mask)
         .field("level", &self.level)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeContentDispositionClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeContentDispositionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeContentDispositionClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeContentTypeClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeContentTypeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeContentTypeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeCryptoContextClass {
    pub parent_class: gobject::GObjectClass,
    pub digest_id: Option<unsafe extern "C" fn(*mut GMimeCryptoContext, *const c_char) -> GMimeDigestAlgo>,
    pub digest_name: Option<unsafe extern "C" fn(*mut GMimeCryptoContext, GMimeDigestAlgo) -> *const c_char>,
    pub get_signature_protocol: Option<unsafe extern "C" fn(*mut GMimeCryptoContext) -> *const c_char>,
    pub get_encryption_protocol: Option<unsafe extern "C" fn(*mut GMimeCryptoContext) -> *const c_char>,
    pub get_key_exchange_protocol: Option<unsafe extern "C" fn(*mut GMimeCryptoContext) -> *const c_char>,
    pub sign: Option<unsafe extern "C" fn(*mut GMimeCryptoContext, gboolean, *const c_char, *mut GMimeStream, *mut GMimeStream, *mut *mut glib::GError) -> c_int>,
    pub verify: Option<unsafe extern "C" fn(*mut GMimeCryptoContext, GMimeVerifyFlags, *mut GMimeStream, *mut GMimeStream, *mut GMimeStream, *mut *mut glib::GError) -> *mut GMimeSignatureList>,
    pub encrypt: Option<unsafe extern "C" fn(*mut GMimeCryptoContext, gboolean, *const c_char, GMimeEncryptFlags, *mut glib::GPtrArray, *mut GMimeStream, *mut GMimeStream, *mut *mut glib::GError) -> c_int>,
    pub decrypt: Option<unsafe extern "C" fn(*mut GMimeCryptoContext, GMimeDecryptFlags, *const c_char, *mut GMimeStream, *mut GMimeStream, *mut *mut glib::GError) -> *mut GMimeDecryptResult>,
    pub import_keys: Option<unsafe extern "C" fn(*mut GMimeCryptoContext, *mut GMimeStream, *mut *mut glib::GError) -> c_int>,
    pub export_keys: Option<unsafe extern "C" fn(*mut GMimeCryptoContext, *const c_char, *mut GMimeStream, *mut *mut glib::GError) -> c_int>,
}

impl ::std::fmt::Debug for GMimeCryptoContextClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeCryptoContextClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("digest_id", &self.digest_id)
         .field("digest_name", &self.digest_name)
         .field("get_signature_protocol", &self.get_signature_protocol)
         .field("get_encryption_protocol", &self.get_encryption_protocol)
         .field("get_key_exchange_protocol", &self.get_key_exchange_protocol)
         .field("sign", &self.sign)
         .field("verify", &self.verify)
         .field("encrypt", &self.encrypt)
         .field("decrypt", &self.decrypt)
         .field("import_keys", &self.import_keys)
         .field("export_keys", &self.export_keys)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeDataWrapperClass {
    pub parent_class: gobject::GObjectClass,
    pub write_to_stream: Option<unsafe extern "C" fn(*mut GMimeDataWrapper, *mut GMimeStream) -> ssize_t>,
}

impl ::std::fmt::Debug for GMimeDataWrapperClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeDataWrapperClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("write_to_stream", &self.write_to_stream)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeDecryptResultClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeDecryptResultClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeDecryptResultClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeEncoding {
    pub encoding: GMimeContentEncoding,
    pub uubuf: [c_uint; 60],
    pub encode: gboolean,
    pub save: u32,
    pub state: c_int,
}

impl ::std::fmt::Debug for GMimeEncoding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeEncoding @ {:?}", self as *const _))
         .field("encoding", &self.encoding)
         .field("encode", &self.encode)
         .field("save", &self.save)
         .field("state", &self.state)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterBasicClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterBasicClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterBasicClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterBestClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterBestClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterBestClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterCharsetClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterCharsetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterCharsetClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterChecksumClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterChecksumClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterChecksumClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterClass {
    pub parent_class: gobject::GObjectClass,
    pub copy: Option<unsafe extern "C" fn(*mut GMimeFilter) -> *mut GMimeFilter>,
    pub filter: Option<unsafe extern "C" fn(*mut GMimeFilter, *mut u8, size_t, size_t, *mut *mut u8, *mut size_t, *mut size_t)>,
    pub complete: Option<unsafe extern "C" fn(*mut GMimeFilter, *mut u8, size_t, size_t, *mut *mut u8, *mut size_t, *mut size_t)>,
    pub reset: Option<unsafe extern "C" fn(*mut GMimeFilter)>,
}

impl ::std::fmt::Debug for GMimeFilterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("copy", &self.copy)
         .field("filter", &self.filter)
         .field("complete", &self.complete)
         .field("reset", &self.reset)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterDos2UnixClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterDos2UnixClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterDos2UnixClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterEnrichedClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterEnrichedClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterEnrichedClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterFromClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterFromClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterFromClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterGZipClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterGZipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterGZipClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterHTMLClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterHTMLClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterHTMLClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterOpenPGPClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterOpenPGPClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterOpenPGPClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterSmtpDataClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterSmtpDataClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterSmtpDataClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterStripClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterStripClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterStripClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterUnix2DosClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterUnix2DosClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterUnix2DosClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterWindowsClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterWindowsClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterWindowsClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterYencClass {
    pub parent_class: GMimeFilterClass,
}

impl ::std::fmt::Debug for GMimeFilterYencClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterYencClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GMimeFormatOptions(c_void);

impl ::std::fmt::Debug for GMimeFormatOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFormatOptions @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GMimeGpgContextClass(c_void);

impl ::std::fmt::Debug for GMimeGpgContextClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeGpgContextClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeHeaderClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeHeaderClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeHeaderClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeHeaderListClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeHeaderListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeHeaderListClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMessageClass {
    pub parent_class: GMimeObjectClass,
}

impl ::std::fmt::Debug for GMimeMessageClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMessageClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMessagePartClass {
    pub parent_class: GMimeObjectClass,
}

impl ::std::fmt::Debug for GMimeMessagePartClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMessagePartClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMessagePartialClass {
    pub parent_class: GMimePartClass,
}

impl ::std::fmt::Debug for GMimeMessagePartialClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMessagePartialClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMultipartClass {
    pub parent_class: GMimeObjectClass,
    pub clear: Option<unsafe extern "C" fn(*mut GMimeMultipart)>,
    pub add: Option<unsafe extern "C" fn(*mut GMimeMultipart, *mut GMimeObject)>,
    pub insert: Option<unsafe extern "C" fn(*mut GMimeMultipart, c_int, *mut GMimeObject)>,
    pub remove: Option<unsafe extern "C" fn(*mut GMimeMultipart, *mut GMimeObject) -> gboolean>,
    pub remove_at: Option<unsafe extern "C" fn(*mut GMimeMultipart, c_int) -> *mut GMimeObject>,
    pub get_part: Option<unsafe extern "C" fn(*mut GMimeMultipart, c_int) -> *mut GMimeObject>,
    pub contains: Option<unsafe extern "C" fn(*mut GMimeMultipart, *mut GMimeObject) -> gboolean>,
    pub index_of: Option<unsafe extern "C" fn(*mut GMimeMultipart, *mut GMimeObject) -> c_int>,
    pub get_count: Option<unsafe extern "C" fn(*mut GMimeMultipart) -> c_int>,
    pub set_boundary: Option<unsafe extern "C" fn(*mut GMimeMultipart, *const c_char)>,
    pub get_boundary: Option<unsafe extern "C" fn(*mut GMimeMultipart) -> *const c_char>,
}

impl ::std::fmt::Debug for GMimeMultipartClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMultipartClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("clear", &self.clear)
         .field("add", &self.add)
         .field("insert", &self.insert)
         .field("remove", &self.remove)
         .field("remove_at", &self.remove_at)
         .field("get_part", &self.get_part)
         .field("contains", &self.contains)
         .field("index_of", &self.index_of)
         .field("get_count", &self.get_count)
         .field("set_boundary", &self.set_boundary)
         .field("get_boundary", &self.get_boundary)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMultipartEncryptedClass {
    pub parent_class: GMimeMultipartClass,
}

impl ::std::fmt::Debug for GMimeMultipartEncryptedClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMultipartEncryptedClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMultipartSignedClass {
    pub parent_class: GMimeMultipartClass,
}

impl ::std::fmt::Debug for GMimeMultipartSignedClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMultipartSignedClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeObjectClass {
    pub parent_class: gobject::GObjectClass,
    pub header_added: Option<unsafe extern "C" fn(*mut GMimeObject, *mut GMimeHeader)>,
    pub header_changed: Option<unsafe extern "C" fn(*mut GMimeObject, *mut GMimeHeader)>,
    pub header_removed: Option<unsafe extern "C" fn(*mut GMimeObject, *mut GMimeHeader)>,
    pub headers_cleared: Option<unsafe extern "C" fn(*mut GMimeObject)>,
    pub set_content_type: Option<unsafe extern "C" fn(*mut GMimeObject, *mut GMimeContentType)>,
    pub get_headers: Option<unsafe extern "C" fn(*mut GMimeObject, *mut GMimeFormatOptions) -> *mut c_char>,
    pub write_to_stream: Option<unsafe extern "C" fn(*mut GMimeObject, *mut GMimeFormatOptions, gboolean, *mut GMimeStream) -> ssize_t>,
    pub encode: Option<unsafe extern "C" fn(*mut GMimeObject, GMimeEncodingConstraint)>,
}

impl ::std::fmt::Debug for GMimeObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeObjectClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("header_added", &self.header_added)
         .field("header_changed", &self.header_changed)
         .field("header_removed", &self.header_removed)
         .field("headers_cleared", &self.headers_cleared)
         .field("set_content_type", &self.set_content_type)
         .field("get_headers", &self.get_headers)
         .field("write_to_stream", &self.write_to_stream)
         .field("encode", &self.encode)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeOpenPGPMarker {
    pub marker: *const c_char,
    pub len: size_t,
    pub before: GMimeOpenPGPState,
    pub after: GMimeOpenPGPState,
    pub is_end_marker: gboolean,
}

impl ::std::fmt::Debug for GMimeOpenPGPMarker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeOpenPGPMarker @ {:?}", self as *const _))
         .field("marker", &self.marker)
         .field("len", &self.len)
         .field("before", &self.before)
         .field("after", &self.after)
         .field("is_end_marker", &self.is_end_marker)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeParamClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeParamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeParamClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeParamListClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeParamListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeParamListClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeParserClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeParserClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeParserClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GMimeParserOptions(c_void);

impl ::std::fmt::Debug for GMimeParserOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeParserOptions @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimePartClass {
    pub parent_class: GMimeObjectClass,
    pub set_content: Option<unsafe extern "C" fn(*mut GMimePart, *mut GMimeDataWrapper)>,
}

impl ::std::fmt::Debug for GMimePartClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimePartClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("set_content", &self.set_content)
         .finish()
    }
}

#[repr(C)]
pub struct GMimePartIter(c_void);

impl ::std::fmt::Debug for GMimePartIter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimePartIter @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GMimePkcs7ContextClass(c_void);

impl ::std::fmt::Debug for GMimePkcs7ContextClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimePkcs7ContextClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeReferences {
    pub array: *mut glib::GPtrArray,
}

impl ::std::fmt::Debug for GMimeReferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeReferences @ {:?}", self as *const _))
         .field("array", &self.array)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeSignatureClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeSignatureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeSignatureClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeSignatureListClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GMimeSignatureListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeSignatureListClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamBufferClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamBufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamBufferClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamCatClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamCatClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamCatClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamClass {
    pub parent_class: gobject::GObjectClass,
    pub read: Option<unsafe extern "C" fn(*mut GMimeStream, *mut u8, size_t) -> ssize_t>,
    pub write: Option<unsafe extern "C" fn(*mut GMimeStream, *const c_char, size_t) -> ssize_t>,
    pub flush: Option<unsafe extern "C" fn(*mut GMimeStream) -> c_int>,
    pub close: Option<unsafe extern "C" fn(*mut GMimeStream) -> c_int>,
    pub eos: Option<unsafe extern "C" fn(*mut GMimeStream) -> gboolean>,
    pub reset: Option<unsafe extern "C" fn(*mut GMimeStream) -> c_int>,
    pub seek: Option<unsafe extern "C" fn(*mut GMimeStream, i64, GMimeSeekWhence) -> i64>,
    pub tell: Option<unsafe extern "C" fn(*mut GMimeStream) -> i64>,
    pub length: Option<unsafe extern "C" fn(*mut GMimeStream) -> i64>,
    pub substream: Option<unsafe extern "C" fn(*mut GMimeStream, i64, i64) -> *mut GMimeStream>,
}

impl ::std::fmt::Debug for GMimeStreamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("read", &self.read)
         .field("write", &self.write)
         .field("flush", &self.flush)
         .field("close", &self.close)
         .field("eos", &self.eos)
         .field("reset", &self.reset)
         .field("seek", &self.seek)
         .field("tell", &self.tell)
         .field("length", &self.length)
         .field("substream", &self.substream)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamFileClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamFileClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamFileClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamFilterClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamFilterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamFilterClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamFsClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamFsClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamFsClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamGIOClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamGIOClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamGIOClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamIOVector {
    pub data: *mut c_void,
    pub len: size_t,
}

impl ::std::fmt::Debug for GMimeStreamIOVector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamIOVector @ {:?}", self as *const _))
         .field("data", &self.data)
         .field("len", &self.len)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamMemClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamMemClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamMemClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamMmapClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamMmapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamMmapClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamNullClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamNullClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamNullClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamPipeClass {
    pub parent_class: GMimeStreamClass,
}

impl ::std::fmt::Debug for GMimeStreamPipeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamPipeClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeTextPartClass {
    pub parent_class: GMimePartClass,
}

impl ::std::fmt::Debug for GMimeTextPartClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeTextPartClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternetAddressClass {
    pub parent_class: gobject::GObjectClass,
    pub to_string: Option<unsafe extern "C" fn(*mut InternetAddress, *mut GMimeFormatOptions, u32, *mut size_t, *mut glib::GString)>,
}

impl ::std::fmt::Debug for InternetAddressClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("InternetAddressClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("to_string", &self.to_string)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternetAddressGroupClass {
    pub parent_class: InternetAddressClass,
}

impl ::std::fmt::Debug for InternetAddressGroupClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("InternetAddressGroupClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternetAddressListClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for InternetAddressListClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("InternetAddressListClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternetAddressMailboxClass {
    pub parent_class: InternetAddressClass,
}

impl ::std::fmt::Debug for InternetAddressMailboxClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("InternetAddressMailboxClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

// Classes
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeApplicationPkcs7Mime {
    pub parent_object: GMimePart,
    pub smime_type: GMimeSecureMimeType,
}

impl ::std::fmt::Debug for GMimeApplicationPkcs7Mime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeApplicationPkcs7Mime @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("smime_type", &self.smime_type)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeAutocryptHeader {
    pub parent_object: gobject::GObject,
    pub address: *mut InternetAddressMailbox,
    pub prefer_encrypt: GMimeAutocryptPreferEncrypt,
    pub keydata: *mut glib::GBytes,
    pub effective_date: *mut glib::GDateTime,
}

impl ::std::fmt::Debug for GMimeAutocryptHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeAutocryptHeader @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("address", &self.address)
         .field("prefer_encrypt", &self.prefer_encrypt)
         .field("keydata", &self.keydata)
         .field("effective_date", &self.effective_date)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeAutocryptHeaderList {
    pub parent_object: gobject::GObject,
    pub array: *mut glib::GPtrArray,
}

impl ::std::fmt::Debug for GMimeAutocryptHeaderList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeAutocryptHeaderList @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeCertificate {
    pub parent_object: gobject::GObject,
    pub pubkey_algo: GMimePubKeyAlgo,
    pub digest_algo: GMimeDigestAlgo,
    pub trust: GMimeTrust,
    pub issuer_serial: *mut c_char,
    pub issuer_name: *mut c_char,
    pub fingerprint: *mut c_char,
    pub created: c_long,
    pub expires: c_long,
    pub keyid: *mut c_char,
    pub email: *mut c_char,
    pub name: *mut c_char,
    pub user_id: *mut c_char,
    pub id_validity: GMimeValidity,
}

impl ::std::fmt::Debug for GMimeCertificate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeCertificate @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("pubkey_algo", &self.pubkey_algo)
         .field("digest_algo", &self.digest_algo)
         .field("trust", &self.trust)
         .field("issuer_serial", &self.issuer_serial)
         .field("issuer_name", &self.issuer_name)
         .field("fingerprint", &self.fingerprint)
         .field("created", &self.created)
         .field("expires", &self.expires)
         .field("keyid", &self.keyid)
         .field("email", &self.email)
         .field("name", &self.name)
         .field("user_id", &self.user_id)
         .field("id_validity", &self.id_validity)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeCertificateList {
    pub parent_object: gobject::GObject,
    pub array: *mut glib::GPtrArray,
}

impl ::std::fmt::Debug for GMimeCertificateList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeCertificateList @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("array", &self.array)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeContentDisposition {
    pub parent_object: gobject::GObject,
    pub disposition: *mut c_char,
    pub params: *mut GMimeParamList,
    pub changed: gpointer,
}

impl ::std::fmt::Debug for GMimeContentDisposition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeContentDisposition @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("disposition", &self.disposition)
         .field("params", &self.params)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeContentType {
    pub parent_object: gobject::GObject,
    pub type_: *mut c_char,
    pub subtype: *mut c_char,
    pub params: *mut GMimeParamList,
    pub changed: gpointer,
}

impl ::std::fmt::Debug for GMimeContentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeContentType @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("type_", &self.type_)
         .field("subtype", &self.subtype)
         .field("params", &self.params)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeCryptoContext {
    pub parent_object: gobject::GObject,
    pub request_passwd: GMimePasswordRequestFunc,
}

impl ::std::fmt::Debug for GMimeCryptoContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeCryptoContext @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("request_passwd", &self.request_passwd)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeDataWrapper {
    pub parent_object: gobject::GObject,
    pub encoding: GMimeContentEncoding,
    pub stream: *mut GMimeStream,
}

impl ::std::fmt::Debug for GMimeDataWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeDataWrapper @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("encoding", &self.encoding)
         .field("stream", &self.stream)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeDecryptResult {
    pub parent_object: gobject::GObject,
    pub recipients: *mut GMimeCertificateList,
    pub signatures: *mut GMimeSignatureList,
    pub cipher: GMimeCipherAlgo,
    pub mdc: GMimeDigestAlgo,
    pub session_key: *mut c_char,
}

impl ::std::fmt::Debug for GMimeDecryptResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeDecryptResult @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("recipients", &self.recipients)
         .field("signatures", &self.signatures)
         .field("cipher", &self.cipher)
         .field("mdc", &self.mdc)
         .field("session_key", &self.session_key)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilter {
    pub parent_object: gobject::GObject,
    pub priv_: *mut _GMimeFilterPrivate,
    pub outreal: *mut c_char,
    pub outbuf: *mut c_char,
    pub outptr: *mut c_char,
    pub outsize: size_t,
    pub outpre: size_t,
    pub backbuf: *mut c_char,
    pub backsize: size_t,
    pub backlen: size_t,
}

impl ::std::fmt::Debug for GMimeFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilter @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("outreal", &self.outreal)
         .field("outbuf", &self.outbuf)
         .field("outptr", &self.outptr)
         .field("outsize", &self.outsize)
         .field("outpre", &self.outpre)
         .field("backbuf", &self.backbuf)
         .field("backsize", &self.backsize)
         .field("backlen", &self.backlen)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterBasic {
    pub parent_object: GMimeFilter,
    pub encoder: GMimeEncoding,
}

impl ::std::fmt::Debug for GMimeFilterBasic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterBasic @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("encoder", &self.encoder)
         .finish()
    }
}

#[repr(C)]
pub struct GMimeFilterBest {
    pub parent_object: GMimeFilter,
    pub flags: GMimeFilterBestFlags,
    pub charset: GMimeCharset,
    pub count0: c_uint,
    pub count8: c_uint,
    pub total: c_uint,
    pub maxline: c_uint,
    pub linelen: c_uint,
    pub frombuf: [c_uint; 6],
    _truncated_record_marker: c_void,
    // /*Ignored*/field fromlen has incomplete type
}

impl ::std::fmt::Debug for GMimeFilterBest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterBest @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("flags", &self.flags)
         .field("charset", &self.charset)
         .field("count0", &self.count0)
         .field("count8", &self.count8)
         .field("total", &self.total)
         .field("maxline", &self.maxline)
         .field("linelen", &self.linelen)
         .field("frombuf", &self.frombuf)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterCharset {
    pub parent_object: GMimeFilter,
    pub from_charset: *mut c_char,
    pub to_charset: *mut c_char,
    pub cd: iconv_t,
}

impl ::std::fmt::Debug for GMimeFilterCharset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterCharset @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("from_charset", &self.from_charset)
         .field("to_charset", &self.to_charset)
         .field("cd", &self.cd)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterChecksum {
    pub parent_object: GMimeFilter,
    pub checksum: *mut glib::GChecksum,
}

impl ::std::fmt::Debug for GMimeFilterChecksum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterChecksum @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("checksum", &self.checksum)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterDos2Unix {
    pub parent_object: GMimeFilter,
    pub ensure_newline: gboolean,
    pub pc: c_char,
}

impl ::std::fmt::Debug for GMimeFilterDos2Unix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterDos2Unix @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("ensure_newline", &self.ensure_newline)
         .field("pc", &self.pc)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterEnriched {
    pub parent_object: GMimeFilter,
    pub flags: u32,
    pub nofill: c_int,
}

impl ::std::fmt::Debug for GMimeFilterEnriched {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterEnriched @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("flags", &self.flags)
         .field("nofill", &self.nofill)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterFrom {
    pub parent_object: GMimeFilter,
    pub mode: GMimeFilterFromMode,
    pub midline: gboolean,
}

impl ::std::fmt::Debug for GMimeFilterFrom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterFrom @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("mode", &self.mode)
         .field("midline", &self.midline)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterGZip {
    pub parent_object: GMimeFilter,
    pub priv_: *mut _GMimeFilterGZipPrivate,
    pub mode: GMimeFilterGZipMode,
    pub level: c_int,
}

impl ::std::fmt::Debug for GMimeFilterGZip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterGZip @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("mode", &self.mode)
         .field("level", &self.level)
         .finish()
    }
}

#[repr(C)]
pub struct GMimeFilterHTML {
    pub parent_object: GMimeFilter,
    pub scanner: *mut _UrlScanner,
    pub flags: u32,
    pub colour: u32,
    _truncated_record_marker: c_void,
    // /*Ignored*/field column has incomplete type
}

impl ::std::fmt::Debug for GMimeFilterHTML {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterHTML @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("scanner", &self.scanner)
         .field("flags", &self.flags)
         .field("colour", &self.colour)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterOpenPGP {
    pub parent_object: GMimeFilter,
    pub state: GMimeOpenPGPState,
    pub seen_end_marker: gboolean,
    pub midline: gboolean,
    pub begin_offset: i64,
    pub end_offset: i64,
    pub position: i64,
    pub next: c_uint,
}

impl ::std::fmt::Debug for GMimeFilterOpenPGP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterOpenPGP @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterSmtpData {
    pub parent_object: GMimeFilter,
    pub bol: gboolean,
}

impl ::std::fmt::Debug for GMimeFilterSmtpData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterSmtpData @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("bol", &self.bol)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterStrip {
    pub parent_object: GMimeFilter,
    pub lwsp: *mut c_void,
}

impl ::std::fmt::Debug for GMimeFilterStrip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterStrip @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterUnix2Dos {
    pub parent_object: GMimeFilter,
    pub ensure_newline: gboolean,
    pub pc: c_char,
}

impl ::std::fmt::Debug for GMimeFilterUnix2Dos {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterUnix2Dos @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("ensure_newline", &self.ensure_newline)
         .field("pc", &self.pc)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterWindows {
    pub parent_object: GMimeFilter,
    pub is_windows: gboolean,
    pub claimed_charset: *mut c_char,
}

impl ::std::fmt::Debug for GMimeFilterWindows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterWindows @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("is_windows", &self.is_windows)
         .field("claimed_charset", &self.claimed_charset)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeFilterYenc {
    pub parent_object: GMimeFilter,
    pub encode: gboolean,
    pub part: c_int,
    pub state: c_int,
    pub pcrc: u32,
    pub crc: u32,
}

impl ::std::fmt::Debug for GMimeFilterYenc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeFilterYenc @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("encode", &self.encode)
         .field("part", &self.part)
         .field("state", &self.state)
         .field("pcrc", &self.pcrc)
         .field("crc", &self.crc)
         .finish()
    }
}

#[repr(C)]
pub struct GMimeGpgContext(c_void);

impl ::std::fmt::Debug for GMimeGpgContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeGpgContext @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeHeader {
    pub parent_object: gobject::GObject,
    pub name: *mut c_char,
    pub value: *mut c_char,
    pub formatter: GMimeHeaderRawValueFormatter,
    pub options: *mut GMimeParserOptions,
    pub reformat: gboolean,
    pub changed: gpointer,
    pub raw_value: *mut c_char,
    pub raw_name: *mut c_char,
    pub charset: *mut c_char,
    pub offset: i64,
}

impl ::std::fmt::Debug for GMimeHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeHeader @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeHeaderList {
    pub parent_object: gobject::GObject,
    pub options: *mut GMimeParserOptions,
    pub changed: gpointer,
    pub hash: *mut glib::GHashTable,
    pub array: *mut glib::GPtrArray,
}

impl ::std::fmt::Debug for GMimeHeaderList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeHeaderList @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMessage {
    pub parent_object: GMimeObject,
    pub addrlists: *mut *mut InternetAddressList,
    pub mime_part: *mut GMimeObject,
    pub message_id: *mut c_char,
    pub date: *mut glib::GDateTime,
    pub subject: *mut c_char,
    pub marker: *mut c_char,
}

impl ::std::fmt::Debug for GMimeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMessage @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("addrlists", &self.addrlists)
         .field("mime_part", &self.mime_part)
         .field("message_id", &self.message_id)
         .field("date", &self.date)
         .field("subject", &self.subject)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMessagePart {
    pub parent_object: GMimeObject,
    pub message: *mut GMimeMessage,
}

impl ::std::fmt::Debug for GMimeMessagePart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMessagePart @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("message", &self.message)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMessagePartial {
    pub parent_object: GMimePart,
    pub number: c_int,
    pub total: c_int,
    pub id: *mut c_char,
}

impl ::std::fmt::Debug for GMimeMessagePartial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMessagePartial @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("number", &self.number)
         .field("total", &self.total)
         .field("id", &self.id)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMultipart {
    pub parent_object: GMimeObject,
    pub children: *mut glib::GPtrArray,
    pub boundary: *mut c_char,
    pub prologue: *mut c_char,
    pub epilogue: *mut c_char,
    pub write_end_boundary: gboolean,
}

impl ::std::fmt::Debug for GMimeMultipart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMultipart @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("children", &self.children)
         .field("boundary", &self.boundary)
         .field("prologue", &self.prologue)
         .field("epilogue", &self.epilogue)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMultipartEncrypted {
    pub parent_object: GMimeMultipart,
}

impl ::std::fmt::Debug for GMimeMultipartEncrypted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMultipartEncrypted @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeMultipartSigned {
    pub parent_object: GMimeMultipart,
}

impl ::std::fmt::Debug for GMimeMultipartSigned {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeMultipartSigned @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeObject {
    pub parent_object: gobject::GObject,
    pub disposition: *mut GMimeContentDisposition,
    pub content_type: *mut GMimeContentType,
    pub headers: *mut GMimeHeaderList,
    pub content_id: *mut c_char,
    pub ensure_newline: gboolean,
}

impl ::std::fmt::Debug for GMimeObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeObject @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("disposition", &self.disposition)
         .field("content_type", &self.content_type)
         .field("headers", &self.headers)
         .field("content_id", &self.content_id)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeParam {
    pub parent_object: gobject::GObject,
    pub method: GMimeParamEncodingMethod,
    pub charset: *mut c_char,
    pub lang: *mut c_char,
    pub name: *mut c_char,
    pub value: *mut c_char,
    pub changed: gpointer,
}

impl ::std::fmt::Debug for GMimeParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeParam @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("method", &self.method)
         .field("charset", &self.charset)
         .field("lang", &self.lang)
         .field("name", &self.name)
         .field("value", &self.value)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeParamList {
    pub parent_object: gobject::GObject,
    pub array: *mut glib::GPtrArray,
    pub changed: gpointer,
}

impl ::std::fmt::Debug for GMimeParamList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeParamList @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeParser {
    pub parent_object: gobject::GObject,
    pub priv_: *mut _GMimeParserPrivate,
}

impl ::std::fmt::Debug for GMimeParser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeParser @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimePart {
    pub parent_object: GMimeObject,
    pub encoding: GMimeContentEncoding,
    pub openpgp: GMimeOpenPGPData,
    pub content_description: *mut c_char,
    pub content_location: *mut c_char,
    pub content_md5: *mut c_char,
    pub content: *mut GMimeDataWrapper,
}

impl ::std::fmt::Debug for GMimePart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimePart @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("encoding", &self.encoding)
         .field("openpgp", &self.openpgp)
         .field("content_description", &self.content_description)
         .field("content_location", &self.content_location)
         .field("content_md5", &self.content_md5)
         .field("content", &self.content)
         .finish()
    }
}

#[repr(C)]
pub struct GMimePkcs7Context(c_void);

impl ::std::fmt::Debug for GMimePkcs7Context {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimePkcs7Context @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeSignature {
    pub parent_object: gobject::GObject,
    pub status: GMimeSignatureStatus,
    pub cert: *mut GMimeCertificate,
    pub created: c_long,
    pub expires: c_long,
}

impl ::std::fmt::Debug for GMimeSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeSignature @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("status", &self.status)
         .field("cert", &self.cert)
         .field("created", &self.created)
         .field("expires", &self.expires)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeSignatureList {
    pub parent_object: gobject::GObject,
    pub array: *mut glib::GPtrArray,
}

impl ::std::fmt::Debug for GMimeSignatureList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeSignatureList @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStream {
    pub parent_object: gobject::GObject,
    pub super_stream: *mut GMimeStream,
    pub position: i64,
    pub bound_start: i64,
    pub bound_end: i64,
}

impl ::std::fmt::Debug for GMimeStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStream @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamBuffer {
    pub parent_object: GMimeStream,
    pub mode: GMimeStreamBufferMode,
    pub source: *mut GMimeStream,
    pub buffer: *mut c_char,
    pub bufptr: *mut c_char,
    pub bufend: *mut c_char,
    pub buflen: size_t,
}

impl ::std::fmt::Debug for GMimeStreamBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamBuffer @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("mode", &self.mode)
         .field("source", &self.source)
         .field("buffer", &self.buffer)
         .field("bufptr", &self.bufptr)
         .field("bufend", &self.bufend)
         .field("buflen", &self.buflen)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamCat {
    pub parent_object: GMimeStream,
    pub sources: *mut _cat_node,
    pub current: *mut _cat_node,
}

impl ::std::fmt::Debug for GMimeStreamCat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamCat @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("sources", &self.sources)
         .field("current", &self.current)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamFile {
    pub parent_object: GMimeStream,
    pub owner: gboolean,
    pub fp: *mut FILE,
}

impl ::std::fmt::Debug for GMimeStreamFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamFile @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("owner", &self.owner)
         .field("fp", &self.fp)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamFilter {
    pub parent_object: GMimeStream,
    pub priv_: *mut _GMimeStreamFilterPrivate,
    pub source: *mut GMimeStream,
    pub owner: gboolean,
}

impl ::std::fmt::Debug for GMimeStreamFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamFilter @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("source", &self.source)
         .field("owner", &self.owner)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamFs {
    pub parent_object: GMimeStream,
    pub owner: gboolean,
    pub eos: gboolean,
    pub fd: c_int,
}

impl ::std::fmt::Debug for GMimeStreamFs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamFs @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("owner", &self.owner)
         .field("eos", &self.eos)
         .field("fd", &self.fd)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamGIO {
    pub parent_object: GMimeStream,
    pub ostream: *mut gio::GOutputStream,
    pub istream: *mut gio::GInputStream,
    pub file: *mut gio::GFile,
    pub owner: gboolean,
    pub eos: gboolean,
}

impl ::std::fmt::Debug for GMimeStreamGIO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamGIO @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("ostream", &self.ostream)
         .field("istream", &self.istream)
         .field("file", &self.file)
         .field("owner", &self.owner)
         .field("eos", &self.eos)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamMem {
    pub parent_object: GMimeStream,
    pub buffer: *mut glib::GByteArray,
    pub owner: gboolean,
}

impl ::std::fmt::Debug for GMimeStreamMem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamMem @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("buffer", &self.buffer)
         .field("owner", &self.owner)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamMmap {
    pub parent_object: GMimeStream,
    pub owner: gboolean,
    pub eos: gboolean,
    pub fd: c_int,
    pub map: *mut c_char,
    pub maplen: size_t,
}

impl ::std::fmt::Debug for GMimeStreamMmap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamMmap @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("owner", &self.owner)
         .field("eos", &self.eos)
         .field("fd", &self.fd)
         .field("map", &self.map)
         .field("maplen", &self.maplen)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamNull {
    pub parent_object: GMimeStream,
    pub written: size_t,
    pub newlines: size_t,
    pub count_newlines: gboolean,
}

impl ::std::fmt::Debug for GMimeStreamNull {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamNull @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("written", &self.written)
         .field("newlines", &self.newlines)
         .field("count_newlines", &self.count_newlines)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeStreamPipe {
    pub parent_object: GMimeStream,
    pub owner: gboolean,
    pub eos: gboolean,
    pub fd: c_int,
}

impl ::std::fmt::Debug for GMimeStreamPipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeStreamPipe @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("owner", &self.owner)
         .field("eos", &self.eos)
         .field("fd", &self.fd)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GMimeTextPart {
    pub parent_object: GMimePart,
}

impl ::std::fmt::Debug for GMimeTextPart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GMimeTextPart @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternetAddress {
    pub parent_object: gobject::GObject,
    pub charset: *mut c_char,
    pub name: *mut c_char,
    pub changed: gpointer,
}

impl ::std::fmt::Debug for InternetAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("InternetAddress @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("charset", &self.charset)
         .field("name", &self.name)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternetAddressGroup {
    pub parent_object: InternetAddress,
    pub members: *mut InternetAddressList,
}

impl ::std::fmt::Debug for InternetAddressGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("InternetAddressGroup @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("members", &self.members)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternetAddressList {
    pub parent_object: gobject::GObject,
    pub array: *mut glib::GPtrArray,
    pub changed: gpointer,
}

impl ::std::fmt::Debug for InternetAddressList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("InternetAddressList @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("array", &self.array)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct InternetAddressMailbox {
    pub parent_object: InternetAddress,
    pub idn_addr: *mut c_char,
    pub addr: *mut c_char,
    pub at: c_int,
}

impl ::std::fmt::Debug for InternetAddressMailbox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("InternetAddressMailbox @ {:?}", self as *const _))
         .field("parent_object", &self.parent_object)
         .field("idn_addr", &self.idn_addr)
         .field("addr", &self.addr)
         .field("at", &self.at)
         .finish()
    }
}

extern "C" {

    //=========================================================================
    // GMimeCharset
    //=========================================================================
    pub fn g_mime_charset_best_name(charset: *mut GMimeCharset) -> *const c_char;
    pub fn g_mime_charset_can_encode(mask: *mut GMimeCharset, charset: *const c_char, text: *const c_char, len: size_t) -> gboolean;
    pub fn g_mime_charset_init(charset: *mut GMimeCharset);
    pub fn g_mime_charset_step(charset: *mut GMimeCharset, inbuf: *const c_char, inlen: size_t);
    pub fn g_mime_charset_best(inbuf: *const c_char, inlen: size_t) -> *const c_char;
    pub fn g_mime_charset_canon_name(charset: *const c_char) -> *const c_char;
    pub fn g_mime_charset_iconv_name(charset: *const c_char) -> *const c_char;
    pub fn g_mime_charset_iso_to_windows(isocharset: *const c_char) -> *const c_char;
    pub fn g_mime_charset_language(charset: *const c_char) -> *const c_char;
    pub fn g_mime_charset_locale_name() -> *const c_char;
    pub fn g_mime_charset_map_init();
    pub fn g_mime_charset_map_shutdown();
    pub fn g_mime_charset_name(charset: *const c_char) -> *const c_char;

    //=========================================================================
    // GMimeEncoding
    //=========================================================================
    pub fn g_mime_encoding_flush(state: *mut GMimeEncoding, inbuf: *const c_char, inlen: size_t, outbuf: *mut c_char) -> size_t;
    pub fn g_mime_encoding_init_decode(state: *mut GMimeEncoding, encoding: GMimeContentEncoding);
    pub fn g_mime_encoding_init_encode(state: *mut GMimeEncoding, encoding: GMimeContentEncoding);
    pub fn g_mime_encoding_outlen(state: *mut GMimeEncoding, inlen: size_t) -> size_t;
    pub fn g_mime_encoding_reset(state: *mut GMimeEncoding);
    pub fn g_mime_encoding_step(state: *mut GMimeEncoding, inbuf: *const c_char, inlen: size_t, outbuf: *mut c_char) -> size_t;
    pub fn g_mime_encoding_base64_decode_step(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, save: *mut u32) -> size_t;
    pub fn g_mime_encoding_base64_encode_close(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, save: *mut u32) -> size_t;
    pub fn g_mime_encoding_base64_encode_step(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, save: *mut u32) -> size_t;
    pub fn g_mime_encoding_quoted_decode_step(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, save: *mut u32) -> size_t;
    pub fn g_mime_encoding_quoted_encode_close(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, save: *mut u32) -> size_t;
    pub fn g_mime_encoding_quoted_encode_step(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, save: *mut u32) -> size_t;
    pub fn g_mime_encoding_uudecode_step(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, save: *mut u32) -> size_t;
    pub fn g_mime_encoding_uuencode_close(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, uubuf: *mut u8, state: *mut c_int, save: *mut u32) -> size_t;
    pub fn g_mime_encoding_uuencode_step(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, uubuf: *mut u8, state: *mut c_int, save: *mut u32) -> size_t;

    //=========================================================================
    // GMimeFormatOptions
    //=========================================================================
    pub fn g_mime_format_options_get_type() -> GType;
    pub fn g_mime_format_options_new() -> *mut GMimeFormatOptions;
    pub fn g_mime_format_options_add_hidden_header(options: *mut GMimeFormatOptions, header: *const c_char);
    pub fn g_mime_format_options_clear_hidden_headers(options: *mut GMimeFormatOptions);
    pub fn g_mime_format_options_clone(options: *mut GMimeFormatOptions) -> *mut GMimeFormatOptions;
    pub fn g_mime_format_options_create_newline_filter(options: *mut GMimeFormatOptions, ensure_newline: gboolean) -> *mut GMimeFilter;
    pub fn g_mime_format_options_free(options: *mut GMimeFormatOptions);
    pub fn g_mime_format_options_get_newline(options: *mut GMimeFormatOptions) -> *const c_char;
    pub fn g_mime_format_options_get_newline_format(options: *mut GMimeFormatOptions) -> GMimeNewLineFormat;
    pub fn g_mime_format_options_get_param_encoding_method(options: *mut GMimeFormatOptions) -> GMimeParamEncodingMethod;
    pub fn g_mime_format_options_is_hidden_header(options: *mut GMimeFormatOptions, header: *const c_char) -> gboolean;
    pub fn g_mime_format_options_remove_hidden_header(options: *mut GMimeFormatOptions, header: *const c_char);
    pub fn g_mime_format_options_set_newline_format(options: *mut GMimeFormatOptions, newline: GMimeNewLineFormat);
    pub fn g_mime_format_options_set_param_encoding_method(options: *mut GMimeFormatOptions, method: GMimeParamEncodingMethod);
    pub fn g_mime_format_options_get_default() -> *mut GMimeFormatOptions;

    //=========================================================================
    // GMimeParserOptions
    //=========================================================================
    pub fn g_mime_parser_options_get_type() -> GType;
    pub fn g_mime_parser_options_new() -> *mut GMimeParserOptions;
    pub fn g_mime_parser_options_clone(options: *mut GMimeParserOptions) -> *mut GMimeParserOptions;
    pub fn g_mime_parser_options_free(options: *mut GMimeParserOptions);
    pub fn g_mime_parser_options_get_address_compliance_mode(options: *mut GMimeParserOptions) -> GMimeRfcComplianceMode;
    pub fn g_mime_parser_options_get_allow_addresses_without_domain(options: *mut GMimeParserOptions) -> gboolean;
    pub fn g_mime_parser_options_get_fallback_charsets(options: *mut GMimeParserOptions) -> *mut *const c_char;
    pub fn g_mime_parser_options_get_parameter_compliance_mode(options: *mut GMimeParserOptions) -> GMimeRfcComplianceMode;
    pub fn g_mime_parser_options_get_rfc2047_compliance_mode(options: *mut GMimeParserOptions) -> GMimeRfcComplianceMode;
    pub fn g_mime_parser_options_get_warning_callback(options: *mut GMimeParserOptions) -> GMimeParserWarningFunc;
    pub fn g_mime_parser_options_set_address_compliance_mode(options: *mut GMimeParserOptions, mode: GMimeRfcComplianceMode);
    pub fn g_mime_parser_options_set_allow_addresses_without_domain(options: *mut GMimeParserOptions, allow: gboolean);
    pub fn g_mime_parser_options_set_fallback_charsets(options: *mut GMimeParserOptions, charsets: *mut *const c_char);
    pub fn g_mime_parser_options_set_parameter_compliance_mode(options: *mut GMimeParserOptions, mode: GMimeRfcComplianceMode);
    pub fn g_mime_parser_options_set_rfc2047_compliance_mode(options: *mut GMimeParserOptions, mode: GMimeRfcComplianceMode);
    pub fn g_mime_parser_options_set_warning_callback(options: *mut GMimeParserOptions, warning_cb: GMimeParserWarningFunc, user_data: gpointer);
    pub fn g_mime_parser_options_get_default() -> *mut GMimeParserOptions;

    //=========================================================================
    // GMimePartIter
    //=========================================================================
    pub fn g_mime_part_iter_get_type() -> GType;
    pub fn g_mime_part_iter_new(toplevel: *mut GMimeObject) -> *mut GMimePartIter;
    pub fn g_mime_part_iter_clone(iter: *mut GMimePartIter) -> *mut GMimePartIter;
    pub fn g_mime_part_iter_free(iter: *mut GMimePartIter);
    pub fn g_mime_part_iter_get_current(iter: *mut GMimePartIter) -> *mut GMimeObject;
    pub fn g_mime_part_iter_get_parent(iter: *mut GMimePartIter) -> *mut GMimeObject;
    pub fn g_mime_part_iter_get_path(iter: *mut GMimePartIter) -> *mut c_char;
    pub fn g_mime_part_iter_get_toplevel(iter: *mut GMimePartIter) -> *mut GMimeObject;
    pub fn g_mime_part_iter_is_valid(iter: *mut GMimePartIter) -> gboolean;
    pub fn g_mime_part_iter_jump_to(iter: *mut GMimePartIter, path: *const c_char) -> gboolean;
    pub fn g_mime_part_iter_next(iter: *mut GMimePartIter) -> gboolean;
    pub fn g_mime_part_iter_prev(iter: *mut GMimePartIter) -> gboolean;
    pub fn g_mime_part_iter_remove(iter: *mut GMimePartIter) -> gboolean;
    pub fn g_mime_part_iter_replace(iter: *mut GMimePartIter, replacement: *mut GMimeObject) -> gboolean;
    pub fn g_mime_part_iter_reset(iter: *mut GMimePartIter);

    //=========================================================================
    // GMimeReferences
    //=========================================================================
    pub fn g_mime_references_get_type() -> GType;
    pub fn g_mime_references_new() -> *mut GMimeReferences;
    pub fn g_mime_references_append(refs: *mut GMimeReferences, msgid: *const c_char);
    pub fn g_mime_references_clear(refs: *mut GMimeReferences);
    pub fn g_mime_references_copy(refs: *mut GMimeReferences) -> *mut GMimeReferences;
    pub fn g_mime_references_free(refs: *mut GMimeReferences);
    pub fn g_mime_references_get_message_id(refs: *mut GMimeReferences, index: c_int) -> *const c_char;
    pub fn g_mime_references_length(refs: *mut GMimeReferences) -> c_int;
    pub fn g_mime_references_set_message_id(refs: *mut GMimeReferences, index: c_int, msgid: *const c_char);
    pub fn g_mime_references_parse(options: *mut GMimeParserOptions, text: *const c_char) -> *mut GMimeReferences;

    //=========================================================================
    // GMimeApplicationPkcs7Mime
    //=========================================================================
    pub fn g_mime_application_pkcs7_mime_get_type() -> GType;
    pub fn g_mime_application_pkcs7_mime_new(type_: GMimeSecureMimeType) -> *mut GMimeApplicationPkcs7Mime;
    pub fn g_mime_application_pkcs7_mime_encrypt(entity: *mut GMimeObject, flags: GMimeEncryptFlags, recipients: *mut glib::GPtrArray, error: *mut *mut glib::GError) -> *mut GMimeApplicationPkcs7Mime;
    pub fn g_mime_application_pkcs7_mime_sign(entity: *mut GMimeObject, userid: *const c_char, error: *mut *mut glib::GError) -> *mut GMimeApplicationPkcs7Mime;
    pub fn g_mime_application_pkcs7_mime_decrypt(pkcs7_mime: *mut GMimeApplicationPkcs7Mime, flags: GMimeDecryptFlags, session_key: *const c_char, result: *mut *mut GMimeDecryptResult, error: *mut *mut glib::GError) -> *mut GMimeObject;
    pub fn g_mime_application_pkcs7_mime_get_smime_type(pkcs7_mime: *mut GMimeApplicationPkcs7Mime) -> GMimeSecureMimeType;
    pub fn g_mime_application_pkcs7_mime_verify(pkcs7_mime: *mut GMimeApplicationPkcs7Mime, flags: GMimeVerifyFlags, entity: *mut *mut GMimeObject, error: *mut *mut glib::GError) -> *mut GMimeSignatureList;

    //=========================================================================
    // GMimeAutocryptHeader
    //=========================================================================
    pub fn g_mime_autocrypt_header_get_type() -> GType;
    pub fn g_mime_autocrypt_header_new() -> *mut GMimeAutocryptHeader;
    pub fn g_mime_autocrypt_header_new_from_string(string: *const c_char) -> *mut GMimeAutocryptHeader;
    pub fn g_mime_autocrypt_header_clone(dst: *mut GMimeAutocryptHeader, src: *mut GMimeAutocryptHeader);
    pub fn g_mime_autocrypt_header_compare(ah1: *mut GMimeAutocryptHeader, ah2: *mut GMimeAutocryptHeader) -> c_int;
    pub fn g_mime_autocrypt_header_get_address(ah: *mut GMimeAutocryptHeader) -> *mut InternetAddressMailbox;
    pub fn g_mime_autocrypt_header_get_address_as_string(ah: *mut GMimeAutocryptHeader) -> *const c_char;
    pub fn g_mime_autocrypt_header_get_effective_date(ah: *mut GMimeAutocryptHeader) -> *mut glib::GDateTime;
    pub fn g_mime_autocrypt_header_get_keydata(ah: *mut GMimeAutocryptHeader) -> *mut glib::GBytes;
    pub fn g_mime_autocrypt_header_get_prefer_encrypt(ah: *mut GMimeAutocryptHeader) -> GMimeAutocryptPreferEncrypt;
    pub fn g_mime_autocrypt_header_is_complete(ah: *mut GMimeAutocryptHeader) -> gboolean;
    pub fn g_mime_autocrypt_header_set_address(ah: *mut GMimeAutocryptHeader, address: *mut InternetAddressMailbox);
    pub fn g_mime_autocrypt_header_set_address_from_string(ah: *mut GMimeAutocryptHeader, address: *const c_char);
    pub fn g_mime_autocrypt_header_set_effective_date(ah: *mut GMimeAutocryptHeader, effective_date: *mut glib::GDateTime);
    pub fn g_mime_autocrypt_header_set_keydata(ah: *mut GMimeAutocryptHeader, data: *mut glib::GBytes);
    pub fn g_mime_autocrypt_header_set_prefer_encrypt(ah: *mut GMimeAutocryptHeader, pref: GMimeAutocryptPreferEncrypt);
    pub fn g_mime_autocrypt_header_to_string(ah: *mut GMimeAutocryptHeader, gossip: gboolean) -> *mut c_char;

    //=========================================================================
    // GMimeAutocryptHeaderList
    //=========================================================================
    pub fn g_mime_autocrypt_header_list_get_type() -> GType;
    pub fn g_mime_autocrypt_header_list_new() -> *mut GMimeAutocryptHeaderList;
    pub fn g_mime_autocrypt_header_list_add(list: *mut GMimeAutocryptHeaderList, header: *mut GMimeAutocryptHeader);
    pub fn g_mime_autocrypt_header_list_add_missing_addresses(list: *mut GMimeAutocryptHeaderList, addresses: *mut InternetAddressList) -> c_uint;
    pub fn g_mime_autocrypt_header_list_get_count(list: *mut GMimeAutocryptHeaderList) -> c_uint;
    pub fn g_mime_autocrypt_header_list_get_header_at(list: *mut GMimeAutocryptHeaderList, index: c_uint) -> *mut GMimeAutocryptHeader;
    pub fn g_mime_autocrypt_header_list_get_header_for_address(list: *mut GMimeAutocryptHeaderList, mailbox: *mut InternetAddressMailbox) -> *mut GMimeAutocryptHeader;
    pub fn g_mime_autocrypt_header_list_remove_incomplete(list: *mut GMimeAutocryptHeaderList);

    //=========================================================================
    // GMimeCertificate
    //=========================================================================
    pub fn g_mime_certificate_get_type() -> GType;
    pub fn g_mime_certificate_new() -> *mut GMimeCertificate;
    pub fn g_mime_certificate_get_created(cert: *mut GMimeCertificate) -> c_long;
    pub fn g_mime_certificate_get_digest_algo(cert: *mut GMimeCertificate) -> GMimeDigestAlgo;
    pub fn g_mime_certificate_get_email(cert: *mut GMimeCertificate) -> *const c_char;
    pub fn g_mime_certificate_get_expires(cert: *mut GMimeCertificate) -> c_long;
    pub fn g_mime_certificate_get_fingerprint(cert: *mut GMimeCertificate) -> *const c_char;
    pub fn g_mime_certificate_get_id_validity(cert: *mut GMimeCertificate) -> GMimeValidity;
    pub fn g_mime_certificate_get_issuer_name(cert: *mut GMimeCertificate) -> *const c_char;
    pub fn g_mime_certificate_get_issuer_serial(cert: *mut GMimeCertificate) -> *const c_char;
    pub fn g_mime_certificate_get_key_id(cert: *mut GMimeCertificate) -> *const c_char;
    pub fn g_mime_certificate_get_name(cert: *mut GMimeCertificate) -> *const c_char;
    pub fn g_mime_certificate_get_pubkey_algo(cert: *mut GMimeCertificate) -> GMimePubKeyAlgo;
    pub fn g_mime_certificate_get_trust(cert: *mut GMimeCertificate) -> GMimeTrust;
    pub fn g_mime_certificate_get_user_id(cert: *mut GMimeCertificate) -> *const c_char;
    pub fn g_mime_certificate_set_created(cert: *mut GMimeCertificate, created: c_long);
    pub fn g_mime_certificate_set_digest_algo(cert: *mut GMimeCertificate, algo: GMimeDigestAlgo);
    pub fn g_mime_certificate_set_email(cert: *mut GMimeCertificate, email: *const c_char);
    pub fn g_mime_certificate_set_expires(cert: *mut GMimeCertificate, expires: c_long);
    pub fn g_mime_certificate_set_fingerprint(cert: *mut GMimeCertificate, fingerprint: *const c_char);
    pub fn g_mime_certificate_set_id_validity(cert: *mut GMimeCertificate, validity: GMimeValidity);
    pub fn g_mime_certificate_set_issuer_name(cert: *mut GMimeCertificate, issuer_name: *const c_char);
    pub fn g_mime_certificate_set_issuer_serial(cert: *mut GMimeCertificate, issuer_serial: *const c_char);
    pub fn g_mime_certificate_set_key_id(cert: *mut GMimeCertificate, key_id: *const c_char);
    pub fn g_mime_certificate_set_name(cert: *mut GMimeCertificate, name: *const c_char);
    pub fn g_mime_certificate_set_pubkey_algo(cert: *mut GMimeCertificate, algo: GMimePubKeyAlgo);
    pub fn g_mime_certificate_set_trust(cert: *mut GMimeCertificate, trust: GMimeTrust);
    pub fn g_mime_certificate_set_user_id(cert: *mut GMimeCertificate, user_id: *const c_char);

    //=========================================================================
    // GMimeCertificateList
    //=========================================================================
    pub fn g_mime_certificate_list_get_type() -> GType;
    pub fn g_mime_certificate_list_new() -> *mut GMimeCertificateList;
    pub fn g_mime_certificate_list_add(list: *mut GMimeCertificateList, cert: *mut GMimeCertificate) -> c_int;
    pub fn g_mime_certificate_list_clear(list: *mut GMimeCertificateList);
    pub fn g_mime_certificate_list_contains(list: *mut GMimeCertificateList, cert: *mut GMimeCertificate) -> gboolean;
    pub fn g_mime_certificate_list_get_certificate(list: *mut GMimeCertificateList, index: c_int) -> *mut GMimeCertificate;
    pub fn g_mime_certificate_list_index_of(list: *mut GMimeCertificateList, cert: *mut GMimeCertificate) -> c_int;
    pub fn g_mime_certificate_list_insert(list: *mut GMimeCertificateList, index: c_int, cert: *mut GMimeCertificate);
    pub fn g_mime_certificate_list_length(list: *mut GMimeCertificateList) -> c_int;
    pub fn g_mime_certificate_list_remove(list: *mut GMimeCertificateList, cert: *mut GMimeCertificate) -> gboolean;
    pub fn g_mime_certificate_list_remove_at(list: *mut GMimeCertificateList, index: c_int) -> gboolean;
    pub fn g_mime_certificate_list_set_certificate(list: *mut GMimeCertificateList, index: c_int, cert: *mut GMimeCertificate);

    //=========================================================================
    // GMimeContentDisposition
    //=========================================================================
    pub fn g_mime_content_disposition_get_type() -> GType;
    pub fn g_mime_content_disposition_new() -> *mut GMimeContentDisposition;
    pub fn g_mime_content_disposition_parse(options: *mut GMimeParserOptions, str: *const c_char) -> *mut GMimeContentDisposition;
    pub fn g_mime_content_disposition_encode(disposition: *mut GMimeContentDisposition, options: *mut GMimeFormatOptions) -> *mut c_char;
    pub fn g_mime_content_disposition_get_disposition(disposition: *mut GMimeContentDisposition) -> *const c_char;
    pub fn g_mime_content_disposition_get_parameter(disposition: *mut GMimeContentDisposition, name: *const c_char) -> *const c_char;
    pub fn g_mime_content_disposition_get_parameters(disposition: *mut GMimeContentDisposition) -> *mut GMimeParamList;
    pub fn g_mime_content_disposition_is_attachment(disposition: *mut GMimeContentDisposition) -> gboolean;
    pub fn g_mime_content_disposition_set_disposition(disposition: *mut GMimeContentDisposition, value: *const c_char);
    pub fn g_mime_content_disposition_set_parameter(disposition: *mut GMimeContentDisposition, name: *const c_char, value: *const c_char);

    //=========================================================================
    // GMimeContentType
    //=========================================================================
    pub fn g_mime_content_type_get_type() -> GType;
    pub fn g_mime_content_type_new(type_: *const c_char, subtype: *const c_char) -> *mut GMimeContentType;
    pub fn g_mime_content_type_parse(options: *mut GMimeParserOptions, str: *const c_char) -> *mut GMimeContentType;
    pub fn g_mime_content_type_encode(content_type: *mut GMimeContentType, options: *mut GMimeFormatOptions) -> *mut c_char;
    pub fn g_mime_content_type_get_media_subtype(content_type: *mut GMimeContentType) -> *const c_char;
    pub fn g_mime_content_type_get_media_type(content_type: *mut GMimeContentType) -> *const c_char;
    pub fn g_mime_content_type_get_mime_type(content_type: *mut GMimeContentType) -> *mut c_char;
    pub fn g_mime_content_type_get_parameter(content_type: *mut GMimeContentType, name: *const c_char) -> *const c_char;
    pub fn g_mime_content_type_get_parameters(content_type: *mut GMimeContentType) -> *mut GMimeParamList;
    pub fn g_mime_content_type_is_type(content_type: *mut GMimeContentType, type_: *const c_char, subtype: *const c_char) -> gboolean;
    pub fn g_mime_content_type_set_media_subtype(content_type: *mut GMimeContentType, subtype: *const c_char);
    pub fn g_mime_content_type_set_media_type(content_type: *mut GMimeContentType, type_: *const c_char);
    pub fn g_mime_content_type_set_parameter(content_type: *mut GMimeContentType, name: *const c_char, value: *const c_char);

    //=========================================================================
    // GMimeCryptoContext
    //=========================================================================
    pub fn g_mime_crypto_context_get_type() -> GType;
    pub fn g_mime_crypto_context_new(protocol: *const c_char) -> *mut GMimeCryptoContext;
    pub fn g_mime_crypto_context_register(protocol: *const c_char, callback: GMimeCryptoContextNewFunc);
    pub fn g_mime_crypto_context_decrypt(ctx: *mut GMimeCryptoContext, flags: GMimeDecryptFlags, session_key: *const c_char, istream: *mut GMimeStream, ostream: *mut GMimeStream, error: *mut *mut glib::GError) -> *mut GMimeDecryptResult;
    pub fn g_mime_crypto_context_digest_id(ctx: *mut GMimeCryptoContext, name: *const c_char) -> GMimeDigestAlgo;
    pub fn g_mime_crypto_context_digest_name(ctx: *mut GMimeCryptoContext, digest: GMimeDigestAlgo) -> *const c_char;
    pub fn g_mime_crypto_context_encrypt(ctx: *mut GMimeCryptoContext, sign: gboolean, userid: *const c_char, flags: GMimeEncryptFlags, recipients: *mut glib::GPtrArray, istream: *mut GMimeStream, ostream: *mut GMimeStream, error: *mut *mut glib::GError) -> c_int;
    pub fn g_mime_crypto_context_export_keys(ctx: *mut GMimeCryptoContext, keys: *const c_char, ostream: *mut GMimeStream, error: *mut *mut glib::GError) -> c_int;
    pub fn g_mime_crypto_context_get_encryption_protocol(ctx: *mut GMimeCryptoContext) -> *const c_char;
    pub fn g_mime_crypto_context_get_key_exchange_protocol(ctx: *mut GMimeCryptoContext) -> *const c_char;
    pub fn g_mime_crypto_context_get_signature_protocol(ctx: *mut GMimeCryptoContext) -> *const c_char;
    pub fn g_mime_crypto_context_import_keys(ctx: *mut GMimeCryptoContext, istream: *mut GMimeStream, error: *mut *mut glib::GError) -> c_int;
    pub fn g_mime_crypto_context_set_request_password(ctx: *mut GMimeCryptoContext, request_passwd: GMimePasswordRequestFunc);
    pub fn g_mime_crypto_context_sign(ctx: *mut GMimeCryptoContext, detach: gboolean, userid: *const c_char, istream: *mut GMimeStream, ostream: *mut GMimeStream, error: *mut *mut glib::GError) -> c_int;
    pub fn g_mime_crypto_context_verify(ctx: *mut GMimeCryptoContext, flags: GMimeVerifyFlags, istream: *mut GMimeStream, sigstream: *mut GMimeStream, ostream: *mut GMimeStream, error: *mut *mut glib::GError) -> *mut GMimeSignatureList;

    //=========================================================================
    // GMimeDataWrapper
    //=========================================================================
    pub fn g_mime_data_wrapper_get_type() -> GType;
    pub fn g_mime_data_wrapper_new() -> *mut GMimeDataWrapper;
    pub fn g_mime_data_wrapper_new_with_stream(stream: *mut GMimeStream, encoding: GMimeContentEncoding) -> *mut GMimeDataWrapper;
    pub fn g_mime_data_wrapper_get_encoding(wrapper: *mut GMimeDataWrapper) -> GMimeContentEncoding;
    pub fn g_mime_data_wrapper_get_stream(wrapper: *mut GMimeDataWrapper) -> *mut GMimeStream;
    pub fn g_mime_data_wrapper_set_encoding(wrapper: *mut GMimeDataWrapper, encoding: GMimeContentEncoding);
    pub fn g_mime_data_wrapper_set_stream(wrapper: *mut GMimeDataWrapper, stream: *mut GMimeStream);
    pub fn g_mime_data_wrapper_write_to_stream(wrapper: *mut GMimeDataWrapper, stream: *mut GMimeStream) -> ssize_t;

    //=========================================================================
    // GMimeDecryptResult
    //=========================================================================
    pub fn g_mime_decrypt_result_get_type() -> GType;
    pub fn g_mime_decrypt_result_new() -> *mut GMimeDecryptResult;
    pub fn g_mime_decrypt_result_get_cipher(result: *mut GMimeDecryptResult) -> GMimeCipherAlgo;
    pub fn g_mime_decrypt_result_get_mdc(result: *mut GMimeDecryptResult) -> GMimeDigestAlgo;
    pub fn g_mime_decrypt_result_get_recipients(result: *mut GMimeDecryptResult) -> *mut GMimeCertificateList;
    pub fn g_mime_decrypt_result_get_session_key(result: *mut GMimeDecryptResult) -> *const c_char;
    pub fn g_mime_decrypt_result_get_signatures(result: *mut GMimeDecryptResult) -> *mut GMimeSignatureList;
    pub fn g_mime_decrypt_result_set_cipher(result: *mut GMimeDecryptResult, cipher: GMimeCipherAlgo);
    pub fn g_mime_decrypt_result_set_mdc(result: *mut GMimeDecryptResult, mdc: GMimeDigestAlgo);
    pub fn g_mime_decrypt_result_set_recipients(result: *mut GMimeDecryptResult, recipients: *mut GMimeCertificateList);
    pub fn g_mime_decrypt_result_set_session_key(result: *mut GMimeDecryptResult, session_key: *const c_char);
    pub fn g_mime_decrypt_result_set_signatures(result: *mut GMimeDecryptResult, signatures: *mut GMimeSignatureList);

    //=========================================================================
    // GMimeFilter
    //=========================================================================
    pub fn g_mime_filter_get_type() -> GType;
    pub fn g_mime_filter_backup(filter: *mut GMimeFilter, data: *mut u8, length: size_t);
    pub fn g_mime_filter_complete(filter: *mut GMimeFilter, inbuf: *mut u8, inlen: size_t, prespace: size_t, outbuf: *mut *mut u8, outlen: *mut size_t, outprespace: *mut size_t);
    pub fn g_mime_filter_copy(filter: *mut GMimeFilter) -> *mut GMimeFilter;
    pub fn g_mime_filter_filter(filter: *mut GMimeFilter, inbuf: *mut u8, inlen: size_t, prespace: size_t, outbuf: *mut *mut u8, outlen: *mut size_t, outprespace: *mut size_t);
    pub fn g_mime_filter_reset(filter: *mut GMimeFilter);
    pub fn g_mime_filter_set_size(filter: *mut GMimeFilter, size: size_t, keep: gboolean);

    //=========================================================================
    // GMimeFilterBasic
    //=========================================================================
    pub fn g_mime_filter_basic_get_type() -> GType;
    pub fn g_mime_filter_basic_new(encoding: GMimeContentEncoding, encode: gboolean) -> *mut GMimeFilter;

    //=========================================================================
    // GMimeFilterBest
    //=========================================================================
    pub fn g_mime_filter_best_get_type() -> GType;
    pub fn g_mime_filter_best_new(flags: GMimeFilterBestFlags) -> *mut GMimeFilter;
    pub fn g_mime_filter_best_charset(best: *mut GMimeFilterBest) -> *const c_char;
    pub fn g_mime_filter_best_encoding(best: *mut GMimeFilterBest, constraint: GMimeEncodingConstraint) -> GMimeContentEncoding;

    //=========================================================================
    // GMimeFilterCharset
    //=========================================================================
    pub fn g_mime_filter_charset_get_type() -> GType;
    pub fn g_mime_filter_charset_new(from_charset: *const c_char, to_charset: *const c_char) -> *mut GMimeFilter;

    //=========================================================================
    // GMimeFilterChecksum
    //=========================================================================
    pub fn g_mime_filter_checksum_get_type() -> GType;
    pub fn g_mime_filter_checksum_new(type_: glib::GChecksumType) -> *mut GMimeFilter;
    pub fn g_mime_filter_checksum_get_digest(checksum: *mut GMimeFilterChecksum, digest: *mut u8, len: size_t) -> size_t;
    pub fn g_mime_filter_checksum_get_string(checksum: *mut GMimeFilterChecksum) -> *mut c_char;

    //=========================================================================
    // GMimeFilterDos2Unix
    //=========================================================================
    pub fn g_mime_filter_dos2unix_get_type() -> GType;
    pub fn g_mime_filter_dos2unix_new(ensure_newline: gboolean) -> *mut GMimeFilter;

    //=========================================================================
    // GMimeFilterEnriched
    //=========================================================================
    pub fn g_mime_filter_enriched_get_type() -> GType;
    pub fn g_mime_filter_enriched_new(flags: u32) -> *mut GMimeFilter;

    //=========================================================================
    // GMimeFilterFrom
    //=========================================================================
    pub fn g_mime_filter_from_get_type() -> GType;
    pub fn g_mime_filter_from_new(mode: GMimeFilterFromMode) -> *mut GMimeFilter;

    //=========================================================================
    // GMimeFilterGZip
    //=========================================================================
    pub fn g_mime_filter_gzip_get_type() -> GType;
    pub fn g_mime_filter_gzip_new(mode: GMimeFilterGZipMode, level: c_int) -> *mut GMimeFilter;
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_filter_gzip_get_comment(gzip: *mut GMimeFilterGZip) -> *const c_char;
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_filter_gzip_get_filename(gzip: *mut GMimeFilterGZip) -> *const c_char;
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_filter_gzip_set_comment(gzip: *mut GMimeFilterGZip, comment: *const c_char);
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_filter_gzip_set_filename(gzip: *mut GMimeFilterGZip, filename: *const c_char);

    //=========================================================================
    // GMimeFilterHTML
    //=========================================================================
    pub fn g_mime_filter_html_get_type() -> GType;
    pub fn g_mime_filter_html_new(flags: u32, colour: u32) -> *mut GMimeFilter;

    //=========================================================================
    // GMimeFilterOpenPGP
    //=========================================================================
    pub fn g_mime_filter_openpgp_get_type() -> GType;
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_filter_openpgp_new() -> *mut GMimeFilter;
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_filter_openpgp_get_begin_offset(openpgp: *mut GMimeFilterOpenPGP) -> i64;
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_filter_openpgp_get_data_type(openpgp: *mut GMimeFilterOpenPGP) -> GMimeOpenPGPData;
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_filter_openpgp_get_end_offset(openpgp: *mut GMimeFilterOpenPGP) -> i64;

    //=========================================================================
    // GMimeFilterSmtpData
    //=========================================================================
    pub fn g_mime_filter_smtp_data_get_type() -> GType;
    pub fn g_mime_filter_smtp_data_new() -> *mut GMimeFilter;

    //=========================================================================
    // GMimeFilterStrip
    //=========================================================================
    pub fn g_mime_filter_strip_get_type() -> GType;
    pub fn g_mime_filter_strip_new() -> *mut GMimeFilter;

    //=========================================================================
    // GMimeFilterUnix2Dos
    //=========================================================================
    pub fn g_mime_filter_unix2dos_get_type() -> GType;
    pub fn g_mime_filter_unix2dos_new(ensure_newline: gboolean) -> *mut GMimeFilter;

    //=========================================================================
    // GMimeFilterWindows
    //=========================================================================
    pub fn g_mime_filter_windows_get_type() -> GType;
    pub fn g_mime_filter_windows_new(claimed_charset: *const c_char) -> *mut GMimeFilter;
    pub fn g_mime_filter_windows_is_windows_charset(filter: *mut GMimeFilterWindows) -> gboolean;
    pub fn g_mime_filter_windows_real_charset(filter: *mut GMimeFilterWindows) -> *const c_char;

    //=========================================================================
    // GMimeFilterYenc
    //=========================================================================
    pub fn g_mime_filter_yenc_get_type() -> GType;
    pub fn g_mime_filter_yenc_new(encode: gboolean) -> *mut GMimeFilter;
    pub fn g_mime_filter_yenc_get_crc(yenc: *mut GMimeFilterYenc) -> u32;
    pub fn g_mime_filter_yenc_get_pcrc(yenc: *mut GMimeFilterYenc) -> u32;
    pub fn g_mime_filter_yenc_set_crc(yenc: *mut GMimeFilterYenc, crc: u32);
    pub fn g_mime_filter_yenc_set_state(yenc: *mut GMimeFilterYenc, state: c_int);

    //=========================================================================
    // GMimeGpgContext
    //=========================================================================
    pub fn g_mime_gpg_context_get_type() -> GType;
    pub fn g_mime_gpg_context_new() -> *mut GMimeCryptoContext;

    //=========================================================================
    // GMimeHeader
    //=========================================================================
    pub fn g_mime_header_get_type() -> GType;
    pub fn g_mime_header_format_addrlist(header: *mut GMimeHeader, options: *mut GMimeFormatOptions, value: *const c_char, charset: *const c_char) -> *mut c_char;
    pub fn g_mime_header_format_content_disposition(header: *mut GMimeHeader, options: *mut GMimeFormatOptions, value: *const c_char, charset: *const c_char) -> *mut c_char;
    pub fn g_mime_header_format_content_type(header: *mut GMimeHeader, options: *mut GMimeFormatOptions, value: *const c_char, charset: *const c_char) -> *mut c_char;
    pub fn g_mime_header_format_default(header: *mut GMimeHeader, options: *mut GMimeFormatOptions, value: *const c_char, charset: *const c_char) -> *mut c_char;
    pub fn g_mime_header_format_message_id(header: *mut GMimeHeader, options: *mut GMimeFormatOptions, value: *const c_char, charset: *const c_char) -> *mut c_char;
    pub fn g_mime_header_format_received(header: *mut GMimeHeader, options: *mut GMimeFormatOptions, value: *const c_char, charset: *const c_char) -> *mut c_char;
    pub fn g_mime_header_format_references(header: *mut GMimeHeader, options: *mut GMimeFormatOptions, value: *const c_char, charset: *const c_char) -> *mut c_char;
    pub fn g_mime_header_get_name(header: *mut GMimeHeader) -> *const c_char;
    pub fn g_mime_header_get_offset(header: *mut GMimeHeader) -> i64;
    pub fn g_mime_header_get_raw_name(header: *mut GMimeHeader) -> *const c_char;
    pub fn g_mime_header_get_raw_value(header: *mut GMimeHeader) -> *const c_char;
    pub fn g_mime_header_get_value(header: *mut GMimeHeader) -> *const c_char;
    pub fn g_mime_header_set_raw_value(header: *mut GMimeHeader, raw_value: *const c_char);
    pub fn g_mime_header_set_value(header: *mut GMimeHeader, options: *mut GMimeFormatOptions, value: *const c_char, charset: *const c_char);
    pub fn g_mime_header_write_to_stream(header: *mut GMimeHeader, options: *mut GMimeFormatOptions, stream: *mut GMimeStream) -> ssize_t;

    //=========================================================================
    // GMimeHeaderList
    //=========================================================================
    pub fn g_mime_header_list_get_type() -> GType;
    pub fn g_mime_header_list_new(options: *mut GMimeParserOptions) -> *mut GMimeHeaderList;
    pub fn g_mime_header_list_append(headers: *mut GMimeHeaderList, name: *const c_char, value: *const c_char, charset: *const c_char);
    pub fn g_mime_header_list_clear(headers: *mut GMimeHeaderList);
    pub fn g_mime_header_list_contains(headers: *mut GMimeHeaderList, name: *const c_char) -> gboolean;
    pub fn g_mime_header_list_get_count(headers: *mut GMimeHeaderList) -> c_int;
    pub fn g_mime_header_list_get_header(headers: *mut GMimeHeaderList, name: *const c_char) -> *mut GMimeHeader;
    pub fn g_mime_header_list_get_header_at(headers: *mut GMimeHeaderList, index: c_int) -> *mut GMimeHeader;
    pub fn g_mime_header_list_prepend(headers: *mut GMimeHeaderList, name: *const c_char, value: *const c_char, charset: *const c_char);
    pub fn g_mime_header_list_remove(headers: *mut GMimeHeaderList, name: *const c_char) -> gboolean;
    pub fn g_mime_header_list_remove_at(headers: *mut GMimeHeaderList, index: c_int);
    pub fn g_mime_header_list_set(headers: *mut GMimeHeaderList, name: *const c_char, value: *const c_char, charset: *const c_char);
    pub fn g_mime_header_list_to_string(headers: *mut GMimeHeaderList, options: *mut GMimeFormatOptions) -> *mut c_char;
    pub fn g_mime_header_list_write_to_stream(headers: *mut GMimeHeaderList, options: *mut GMimeFormatOptions, stream: *mut GMimeStream) -> ssize_t;

    //=========================================================================
    // GMimeMessage
    //=========================================================================
    pub fn g_mime_message_get_type() -> GType;
    pub fn g_mime_message_new(pretty_headers: gboolean) -> *mut GMimeMessage;
    pub fn g_mime_message_add_mailbox(message: *mut GMimeMessage, type_: GMimeAddressType, name: *const c_char, addr: *const c_char);
    pub fn g_mime_message_foreach(message: *mut GMimeMessage, callback: GMimeObjectForeachFunc, user_data: gpointer);
    pub fn g_mime_message_get_addresses(message: *mut GMimeMessage, type_: GMimeAddressType) -> *mut InternetAddressList;
    pub fn g_mime_message_get_all_recipients(message: *mut GMimeMessage) -> *mut InternetAddressList;
    pub fn g_mime_message_get_autocrypt_gossip_headers(message: *mut GMimeMessage, now: *mut glib::GDateTime, flags: GMimeDecryptFlags, session_key: *const c_char, error: *mut *mut glib::GError) -> *mut GMimeAutocryptHeaderList;
    pub fn g_mime_message_get_autocrypt_gossip_headers_from_inner_part(message: *mut GMimeMessage, now: *mut glib::GDateTime, inner_part: *mut GMimeObject) -> *mut GMimeAutocryptHeaderList;
    pub fn g_mime_message_get_autocrypt_header(message: *mut GMimeMessage, now: *mut glib::GDateTime) -> *mut GMimeAutocryptHeader;
    pub fn g_mime_message_get_bcc(message: *mut GMimeMessage) -> *mut InternetAddressList;
    pub fn g_mime_message_get_body(message: *mut GMimeMessage) -> *mut GMimeObject;
    pub fn g_mime_message_get_cc(message: *mut GMimeMessage) -> *mut InternetAddressList;
    pub fn g_mime_message_get_date(message: *mut GMimeMessage) -> *mut glib::GDateTime;
    pub fn g_mime_message_get_from(message: *mut GMimeMessage) -> *mut InternetAddressList;
    pub fn g_mime_message_get_message_id(message: *mut GMimeMessage) -> *const c_char;
    pub fn g_mime_message_get_mime_part(message: *mut GMimeMessage) -> *mut GMimeObject;
    pub fn g_mime_message_get_reply_to(message: *mut GMimeMessage) -> *mut InternetAddressList;
    pub fn g_mime_message_get_sender(message: *mut GMimeMessage) -> *mut InternetAddressList;
    pub fn g_mime_message_get_subject(message: *mut GMimeMessage) -> *const c_char;
    pub fn g_mime_message_get_to(message: *mut GMimeMessage) -> *mut InternetAddressList;
    pub fn g_mime_message_partial_split_message(message: *mut GMimeMessage, max_size: size_t, nparts: *mut size_t) -> *mut *mut GMimeMessage;
    pub fn g_mime_message_set_date(message: *mut GMimeMessage, date: *mut glib::GDateTime);
    pub fn g_mime_message_set_message_id(message: *mut GMimeMessage, message_id: *const c_char);
    pub fn g_mime_message_set_mime_part(message: *mut GMimeMessage, mime_part: *mut GMimeObject);
    pub fn g_mime_message_set_subject(message: *mut GMimeMessage, subject: *const c_char, charset: *const c_char);

    //=========================================================================
    // GMimeMessagePart
    //=========================================================================
    pub fn g_mime_message_part_get_type() -> GType;
    pub fn g_mime_message_part_new(subtype: *const c_char) -> *mut GMimeMessagePart;
    pub fn g_mime_message_part_new_with_message(subtype: *const c_char, message: *mut GMimeMessage) -> *mut GMimeMessagePart;
    pub fn g_mime_message_part_get_message(part: *mut GMimeMessagePart) -> *mut GMimeMessage;
    pub fn g_mime_message_part_set_message(part: *mut GMimeMessagePart, message: *mut GMimeMessage);

    //=========================================================================
    // GMimeMessagePartial
    //=========================================================================
    pub fn g_mime_message_partial_get_type() -> GType;
    pub fn g_mime_message_partial_new(id: *const c_char, number: c_int, total: c_int) -> *mut GMimeMessagePartial;
    pub fn g_mime_message_partial_reconstruct_message(partials: *mut *mut GMimeMessagePartial, num: size_t) -> *mut GMimeMessage;
    pub fn g_mime_message_partial_get_id(partial: *mut GMimeMessagePartial) -> *const c_char;
    pub fn g_mime_message_partial_get_number(partial: *mut GMimeMessagePartial) -> c_int;
    pub fn g_mime_message_partial_get_total(partial: *mut GMimeMessagePartial) -> c_int;

    //=========================================================================
    // GMimeMultipart
    //=========================================================================
    pub fn g_mime_multipart_get_type() -> GType;
    pub fn g_mime_multipart_new() -> *mut GMimeMultipart;
    pub fn g_mime_multipart_new_with_subtype(subtype: *const c_char) -> *mut GMimeMultipart;
    pub fn g_mime_multipart_add(multipart: *mut GMimeMultipart, part: *mut GMimeObject);
    pub fn g_mime_multipart_clear(multipart: *mut GMimeMultipart);
    pub fn g_mime_multipart_contains(multipart: *mut GMimeMultipart, part: *mut GMimeObject) -> gboolean;
    pub fn g_mime_multipart_foreach(multipart: *mut GMimeMultipart, callback: GMimeObjectForeachFunc, user_data: gpointer);
    pub fn g_mime_multipart_get_boundary(multipart: *mut GMimeMultipart) -> *const c_char;
    pub fn g_mime_multipart_get_count(multipart: *mut GMimeMultipart) -> c_int;
    pub fn g_mime_multipart_get_epilogue(multipart: *mut GMimeMultipart) -> *const c_char;
    pub fn g_mime_multipart_get_part(multipart: *mut GMimeMultipart, index: c_int) -> *mut GMimeObject;
    pub fn g_mime_multipart_get_prologue(multipart: *mut GMimeMultipart) -> *const c_char;
    pub fn g_mime_multipart_get_subpart_from_content_id(multipart: *mut GMimeMultipart, content_id: *const c_char) -> *mut GMimeObject;
    pub fn g_mime_multipart_index_of(multipart: *mut GMimeMultipart, part: *mut GMimeObject) -> c_int;
    pub fn g_mime_multipart_insert(multipart: *mut GMimeMultipart, index: c_int, part: *mut GMimeObject);
    pub fn g_mime_multipart_remove(multipart: *mut GMimeMultipart, part: *mut GMimeObject) -> gboolean;
    pub fn g_mime_multipart_remove_at(multipart: *mut GMimeMultipart, index: c_int) -> *mut GMimeObject;
    pub fn g_mime_multipart_replace(multipart: *mut GMimeMultipart, index: c_int, replacement: *mut GMimeObject) -> *mut GMimeObject;
    pub fn g_mime_multipart_set_boundary(multipart: *mut GMimeMultipart, boundary: *const c_char);
    pub fn g_mime_multipart_set_epilogue(multipart: *mut GMimeMultipart, epilogue: *const c_char);
    pub fn g_mime_multipart_set_prologue(multipart: *mut GMimeMultipart, prologue: *const c_char);

    //=========================================================================
    // GMimeMultipartEncrypted
    //=========================================================================
    pub fn g_mime_multipart_encrypted_get_type() -> GType;
    pub fn g_mime_multipart_encrypted_new() -> *mut GMimeMultipartEncrypted;
    pub fn g_mime_multipart_encrypted_encrypt(ctx: *mut GMimeCryptoContext, entity: *mut GMimeObject, sign: gboolean, userid: *const c_char, flags: GMimeEncryptFlags, recipients: *mut glib::GPtrArray, error: *mut *mut glib::GError) -> *mut GMimeMultipartEncrypted;
    pub fn g_mime_multipart_encrypted_decrypt(encrypted: *mut GMimeMultipartEncrypted, flags: GMimeDecryptFlags, session_key: *const c_char, result: *mut *mut GMimeDecryptResult, error: *mut *mut glib::GError) -> *mut GMimeObject;

    //=========================================================================
    // GMimeMultipartSigned
    //=========================================================================
    pub fn g_mime_multipart_signed_get_type() -> GType;
    pub fn g_mime_multipart_signed_new() -> *mut GMimeMultipartSigned;
    pub fn g_mime_multipart_signed_sign(ctx: *mut GMimeCryptoContext, entity: *mut GMimeObject, userid: *const c_char, error: *mut *mut glib::GError) -> *mut GMimeMultipartSigned;
    pub fn g_mime_multipart_signed_verify(mps: *mut GMimeMultipartSigned, flags: GMimeVerifyFlags, error: *mut *mut glib::GError) -> *mut GMimeSignatureList;

    //=========================================================================
    // GMimeObject
    //=========================================================================
    pub fn g_mime_object_get_type() -> GType;
    pub fn g_mime_object_new(options: *mut GMimeParserOptions, content_type: *mut GMimeContentType) -> *mut GMimeObject;
    pub fn g_mime_object_new_type(options: *mut GMimeParserOptions, type_: *const c_char, subtype: *const c_char) -> *mut GMimeObject;
    pub fn g_mime_object_register_type(type_: *const c_char, subtype: *const c_char, object_type: GType);
    pub fn g_mime_object_type_registry_init();
    pub fn g_mime_object_type_registry_shutdown();
    pub fn g_mime_object_append_header(object: *mut GMimeObject, header: *const c_char, value: *const c_char, charset: *const c_char);
    pub fn g_mime_object_encode(object: *mut GMimeObject, constraint: GMimeEncodingConstraint);
    pub fn g_mime_object_get_autocrypt_headers(mime_part: *mut GMimeObject, effective_date: *mut glib::GDateTime, matchheader: *const c_char, addresses: *mut InternetAddressList, keep_incomplete: gboolean) -> *mut GMimeAutocryptHeaderList;
    pub fn g_mime_object_get_content_disposition(object: *mut GMimeObject) -> *mut GMimeContentDisposition;
    pub fn g_mime_object_get_content_disposition_parameter(object: *mut GMimeObject, name: *const c_char) -> *const c_char;
    pub fn g_mime_object_get_content_id(object: *mut GMimeObject) -> *const c_char;
    pub fn g_mime_object_get_content_type(object: *mut GMimeObject) -> *mut GMimeContentType;
    pub fn g_mime_object_get_content_type_parameter(object: *mut GMimeObject, name: *const c_char) -> *const c_char;
    pub fn g_mime_object_get_disposition(object: *mut GMimeObject) -> *const c_char;
    pub fn g_mime_object_get_header(object: *mut GMimeObject, header: *const c_char) -> *const c_char;
    pub fn g_mime_object_get_header_list(object: *mut GMimeObject) -> *mut GMimeHeaderList;
    pub fn g_mime_object_get_headers(object: *mut GMimeObject, options: *mut GMimeFormatOptions) -> *mut c_char;
    pub fn g_mime_object_prepend_header(object: *mut GMimeObject, header: *const c_char, value: *const c_char, charset: *const c_char);
    pub fn g_mime_object_remove_header(object: *mut GMimeObject, header: *const c_char) -> gboolean;
    pub fn g_mime_object_set_content_disposition(object: *mut GMimeObject, disposition: *mut GMimeContentDisposition);
    pub fn g_mime_object_set_content_disposition_parameter(object: *mut GMimeObject, name: *const c_char, value: *const c_char);
    pub fn g_mime_object_set_content_id(object: *mut GMimeObject, content_id: *const c_char);
    pub fn g_mime_object_set_content_type(object: *mut GMimeObject, content_type: *mut GMimeContentType);
    pub fn g_mime_object_set_content_type_parameter(object: *mut GMimeObject, name: *const c_char, value: *const c_char);
    pub fn g_mime_object_set_disposition(object: *mut GMimeObject, disposition: *const c_char);
    pub fn g_mime_object_set_header(object: *mut GMimeObject, header: *const c_char, value: *const c_char, charset: *const c_char);
    pub fn g_mime_object_to_string(object: *mut GMimeObject, options: *mut GMimeFormatOptions) -> *mut c_char;
    pub fn g_mime_object_write_to_stream(object: *mut GMimeObject, options: *mut GMimeFormatOptions, stream: *mut GMimeStream) -> ssize_t;

    //=========================================================================
    // GMimeParam
    //=========================================================================
    pub fn g_mime_param_get_type() -> GType;
    pub fn g_mime_param_get_charset(param: *mut GMimeParam) -> *const c_char;
    pub fn g_mime_param_get_encoding_method(param: *mut GMimeParam) -> GMimeParamEncodingMethod;
    pub fn g_mime_param_get_lang(param: *mut GMimeParam) -> *const c_char;
    pub fn g_mime_param_get_name(param: *mut GMimeParam) -> *const c_char;
    pub fn g_mime_param_get_value(param: *mut GMimeParam) -> *const c_char;
    pub fn g_mime_param_set_charset(param: *mut GMimeParam, charset: *const c_char);
    pub fn g_mime_param_set_encoding_method(param: *mut GMimeParam, method: GMimeParamEncodingMethod);
    pub fn g_mime_param_set_lang(param: *mut GMimeParam, lang: *const c_char);
    pub fn g_mime_param_set_value(param: *mut GMimeParam, value: *const c_char);

    //=========================================================================
    // GMimeParamList
    //=========================================================================
    pub fn g_mime_param_list_get_type() -> GType;
    pub fn g_mime_param_list_new() -> *mut GMimeParamList;
    pub fn g_mime_param_list_parse(options: *mut GMimeParserOptions, str: *const c_char) -> *mut GMimeParamList;
    pub fn g_mime_param_list_clear(list: *mut GMimeParamList);
    pub fn g_mime_param_list_encode(list: *mut GMimeParamList, options: *mut GMimeFormatOptions, fold: gboolean, str: *mut glib::GString);
    pub fn g_mime_param_list_get_parameter(list: *mut GMimeParamList, name: *const c_char) -> *mut GMimeParam;
    pub fn g_mime_param_list_get_parameter_at(list: *mut GMimeParamList, index: c_int) -> *mut GMimeParam;
    pub fn g_mime_param_list_length(list: *mut GMimeParamList) -> c_int;
    pub fn g_mime_param_list_remove(list: *mut GMimeParamList, name: *const c_char) -> gboolean;
    pub fn g_mime_param_list_remove_at(list: *mut GMimeParamList, index: c_int) -> gboolean;
    pub fn g_mime_param_list_set_parameter(list: *mut GMimeParamList, name: *const c_char, value: *const c_char);

    //=========================================================================
    // GMimeParser
    //=========================================================================
    pub fn g_mime_parser_get_type() -> GType;
    pub fn g_mime_parser_new() -> *mut GMimeParser;
    pub fn g_mime_parser_new_with_stream(stream: *mut GMimeStream) -> *mut GMimeParser;
    pub fn g_mime_parser_construct_message(parser: *mut GMimeParser, options: *mut GMimeParserOptions) -> *mut GMimeMessage;
    pub fn g_mime_parser_construct_part(parser: *mut GMimeParser, options: *mut GMimeParserOptions) -> *mut GMimeObject;
    pub fn g_mime_parser_eos(parser: *mut GMimeParser) -> gboolean;
    pub fn g_mime_parser_get_format(parser: *mut GMimeParser) -> GMimeFormat;
    pub fn g_mime_parser_get_headers_begin(parser: *mut GMimeParser) -> i64;
    pub fn g_mime_parser_get_headers_end(parser: *mut GMimeParser) -> i64;
    pub fn g_mime_parser_get_mbox_marker(parser: *mut GMimeParser) -> *mut c_char;
    pub fn g_mime_parser_get_mbox_marker_offset(parser: *mut GMimeParser) -> i64;
    pub fn g_mime_parser_get_persist_stream(parser: *mut GMimeParser) -> gboolean;
    pub fn g_mime_parser_get_respect_content_length(parser: *mut GMimeParser) -> gboolean;
    pub fn g_mime_parser_init_with_stream(parser: *mut GMimeParser, stream: *mut GMimeStream);
    pub fn g_mime_parser_set_format(parser: *mut GMimeParser, format: GMimeFormat);
    pub fn g_mime_parser_set_header_regex(parser: *mut GMimeParser, regex: *const c_char, header_cb: GMimeParserHeaderRegexFunc, user_data: gpointer);
    pub fn g_mime_parser_set_persist_stream(parser: *mut GMimeParser, persist: gboolean);
    pub fn g_mime_parser_set_respect_content_length(parser: *mut GMimeParser, respect_content_length: gboolean);
    pub fn g_mime_parser_tell(parser: *mut GMimeParser) -> i64;

    //=========================================================================
    // GMimePart
    //=========================================================================
    pub fn g_mime_part_get_type() -> GType;
    pub fn g_mime_part_new() -> *mut GMimePart;
    pub fn g_mime_part_new_with_type(type_: *const c_char, subtype: *const c_char) -> *mut GMimePart;
    pub fn g_mime_part_get_best_content_encoding(mime_part: *mut GMimePart, constraint: GMimeEncodingConstraint) -> GMimeContentEncoding;
    pub fn g_mime_part_get_content(mime_part: *mut GMimePart) -> *mut GMimeDataWrapper;
    pub fn g_mime_part_get_content_description(mime_part: *mut GMimePart) -> *const c_char;
    pub fn g_mime_part_get_content_encoding(mime_part: *mut GMimePart) -> GMimeContentEncoding;
    pub fn g_mime_part_get_content_id(mime_part: *mut GMimePart) -> *const c_char;
    pub fn g_mime_part_get_content_location(mime_part: *mut GMimePart) -> *const c_char;
    pub fn g_mime_part_get_content_md5(mime_part: *mut GMimePart) -> *const c_char;
    pub fn g_mime_part_get_filename(mime_part: *mut GMimePart) -> *const c_char;
    pub fn g_mime_part_get_openpgp_data(mime_part: *mut GMimePart) -> GMimeOpenPGPData;
    pub fn g_mime_part_is_attachment(mime_part: *mut GMimePart) -> gboolean;
    pub fn g_mime_part_openpgp_decrypt(mime_part: *mut GMimePart, flags: GMimeDecryptFlags, session_key: *const c_char, error: *mut *mut glib::GError) -> *mut GMimeDecryptResult;
    pub fn g_mime_part_openpgp_encrypt(mime_part: *mut GMimePart, sign: gboolean, userid: *const c_char, flags: GMimeEncryptFlags, recipients: *mut glib::GPtrArray, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_mime_part_openpgp_sign(mime_part: *mut GMimePart, userid: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn g_mime_part_openpgp_verify(mime_part: *mut GMimePart, flags: GMimeVerifyFlags, error: *mut *mut glib::GError) -> *mut GMimeSignatureList;
    pub fn g_mime_part_set_content(mime_part: *mut GMimePart, content: *mut GMimeDataWrapper);
    pub fn g_mime_part_set_content_description(mime_part: *mut GMimePart, description: *const c_char);
    pub fn g_mime_part_set_content_encoding(mime_part: *mut GMimePart, encoding: GMimeContentEncoding);
    pub fn g_mime_part_set_content_id(mime_part: *mut GMimePart, content_id: *const c_char);
    pub fn g_mime_part_set_content_location(mime_part: *mut GMimePart, content_location: *const c_char);
    pub fn g_mime_part_set_content_md5(mime_part: *mut GMimePart, content_md5: *const c_char);
    pub fn g_mime_part_set_filename(mime_part: *mut GMimePart, filename: *const c_char);
    pub fn g_mime_part_set_openpgp_data(mime_part: *mut GMimePart, data: GMimeOpenPGPData);
    pub fn g_mime_part_verify_content_md5(mime_part: *mut GMimePart) -> gboolean;

    //=========================================================================
    // GMimePkcs7Context
    //=========================================================================
    pub fn g_mime_pkcs7_context_get_type() -> GType;
    pub fn g_mime_pkcs7_context_new() -> *mut GMimeCryptoContext;

    //=========================================================================
    // GMimeSignature
    //=========================================================================
    pub fn g_mime_signature_get_type() -> GType;
    pub fn g_mime_signature_new() -> *mut GMimeSignature;
    pub fn g_mime_signature_get_certificate(sig: *mut GMimeSignature) -> *mut GMimeCertificate;
    pub fn g_mime_signature_get_created(sig: *mut GMimeSignature) -> c_long;
    pub fn g_mime_signature_get_expires(sig: *mut GMimeSignature) -> c_long;
    pub fn g_mime_signature_get_status(sig: *mut GMimeSignature) -> GMimeSignatureStatus;
    pub fn g_mime_signature_set_certificate(sig: *mut GMimeSignature, cert: *mut GMimeCertificate);
    pub fn g_mime_signature_set_created(sig: *mut GMimeSignature, created: c_long);
    pub fn g_mime_signature_set_expires(sig: *mut GMimeSignature, expires: c_long);
    pub fn g_mime_signature_set_status(sig: *mut GMimeSignature, status: GMimeSignatureStatus);

    //=========================================================================
    // GMimeSignatureList
    //=========================================================================
    pub fn g_mime_signature_list_get_type() -> GType;
    pub fn g_mime_signature_list_new() -> *mut GMimeSignatureList;
    pub fn g_mime_signature_list_add(list: *mut GMimeSignatureList, sig: *mut GMimeSignature) -> c_int;
    pub fn g_mime_signature_list_clear(list: *mut GMimeSignatureList);
    pub fn g_mime_signature_list_contains(list: *mut GMimeSignatureList, sig: *mut GMimeSignature) -> gboolean;
    pub fn g_mime_signature_list_get_signature(list: *mut GMimeSignatureList, index: c_int) -> *mut GMimeSignature;
    pub fn g_mime_signature_list_index_of(list: *mut GMimeSignatureList, sig: *mut GMimeSignature) -> c_int;
    pub fn g_mime_signature_list_insert(list: *mut GMimeSignatureList, index: c_int, sig: *mut GMimeSignature);
    pub fn g_mime_signature_list_length(list: *mut GMimeSignatureList) -> c_int;
    pub fn g_mime_signature_list_remove(list: *mut GMimeSignatureList, sig: *mut GMimeSignature) -> gboolean;
    pub fn g_mime_signature_list_remove_at(list: *mut GMimeSignatureList, index: c_int) -> gboolean;
    pub fn g_mime_signature_list_set_signature(list: *mut GMimeSignatureList, index: c_int, sig: *mut GMimeSignature);

    //=========================================================================
    // GMimeStream
    //=========================================================================
    pub fn g_mime_stream_get_type() -> GType;
    pub fn g_mime_stream_buffer_gets(stream: *mut GMimeStream, buf: *mut c_char, max: size_t) -> ssize_t;
    pub fn g_mime_stream_buffer_readln(stream: *mut GMimeStream, buffer: *mut glib::GByteArray);
    pub fn g_mime_stream_close(stream: *mut GMimeStream) -> c_int;
    pub fn g_mime_stream_construct(stream: *mut GMimeStream, start: i64, end: i64);
    pub fn g_mime_stream_eos(stream: *mut GMimeStream) -> gboolean;
    pub fn g_mime_stream_flush(stream: *mut GMimeStream) -> c_int;
    pub fn g_mime_stream_length(stream: *mut GMimeStream) -> i64;
    pub fn g_mime_stream_printf(stream: *mut GMimeStream, fmt: *const c_char, ...) -> ssize_t;
    pub fn g_mime_stream_read(stream: *mut GMimeStream, buf: *mut u8, len: size_t) -> ssize_t;
    pub fn g_mime_stream_reset(stream: *mut GMimeStream) -> c_int;
    pub fn g_mime_stream_seek(stream: *mut GMimeStream, offset: i64, whence: GMimeSeekWhence) -> i64;
    pub fn g_mime_stream_set_bounds(stream: *mut GMimeStream, start: i64, end: i64);
    pub fn g_mime_stream_substream(stream: *mut GMimeStream, start: i64, end: i64) -> *mut GMimeStream;
    pub fn g_mime_stream_tell(stream: *mut GMimeStream) -> i64;
    pub fn g_mime_stream_write(stream: *mut GMimeStream, buf: *const c_char, len: size_t) -> ssize_t;
    pub fn g_mime_stream_write_string(stream: *mut GMimeStream, str: *const c_char) -> ssize_t;
    pub fn g_mime_stream_write_to_stream(src: *mut GMimeStream, dest: *mut GMimeStream) -> i64;
    pub fn g_mime_stream_writev(stream: *mut GMimeStream, vector: *mut GMimeStreamIOVector, count: size_t) -> i64;

    //=========================================================================
    // GMimeStreamBuffer
    //=========================================================================
    pub fn g_mime_stream_buffer_get_type() -> GType;
    pub fn g_mime_stream_buffer_new(source: *mut GMimeStream, mode: GMimeStreamBufferMode) -> *mut GMimeStream;

    //=========================================================================
    // GMimeStreamCat
    //=========================================================================
    pub fn g_mime_stream_cat_get_type() -> GType;
    pub fn g_mime_stream_cat_new() -> *mut GMimeStream;
    pub fn g_mime_stream_cat_add_source(cat: *mut GMimeStreamCat, source: *mut GMimeStream) -> c_int;

    //=========================================================================
    // GMimeStreamFile
    //=========================================================================
    pub fn g_mime_stream_file_get_type() -> GType;
    pub fn g_mime_stream_file_new(fp: *mut FILE) -> *mut GMimeStream;
    pub fn g_mime_stream_file_new_with_bounds(fp: *mut FILE, start: i64, end: i64) -> *mut GMimeStream;
    pub fn g_mime_stream_file_open(path: *const c_char, mode: *const c_char, error: *mut *mut glib::GError) -> *mut GMimeStream;
    pub fn g_mime_stream_file_get_owner(stream: *mut GMimeStreamFile) -> gboolean;
    pub fn g_mime_stream_file_set_owner(stream: *mut GMimeStreamFile, owner: gboolean);

    //=========================================================================
    // GMimeStreamFilter
    //=========================================================================
    pub fn g_mime_stream_filter_get_type() -> GType;
    pub fn g_mime_stream_filter_new(stream: *mut GMimeStream) -> *mut GMimeStream;
    pub fn g_mime_stream_filter_add(stream: *mut GMimeStreamFilter, filter: *mut GMimeFilter) -> c_int;
    pub fn g_mime_stream_filter_get_owner(stream: *mut GMimeStreamFilter) -> gboolean;
    pub fn g_mime_stream_filter_remove(stream: *mut GMimeStreamFilter, id: c_int);
    pub fn g_mime_stream_filter_set_owner(stream: *mut GMimeStreamFilter, owner: gboolean);

    //=========================================================================
    // GMimeStreamFs
    //=========================================================================
    pub fn g_mime_stream_fs_get_type() -> GType;
    pub fn g_mime_stream_fs_new(fd: c_int) -> *mut GMimeStream;
    pub fn g_mime_stream_fs_new_with_bounds(fd: c_int, start: i64, end: i64) -> *mut GMimeStream;
    pub fn g_mime_stream_fs_open(path: *const c_char, flags: c_int, mode: c_int, error: *mut *mut glib::GError) -> *mut GMimeStream;
    pub fn g_mime_stream_fs_get_owner(stream: *mut GMimeStreamFs) -> gboolean;
    pub fn g_mime_stream_fs_set_owner(stream: *mut GMimeStreamFs, owner: gboolean);

    //=========================================================================
    // GMimeStreamGIO
    //=========================================================================
    pub fn g_mime_stream_gio_get_type() -> GType;
    pub fn g_mime_stream_gio_new(file: *mut gio::GFile) -> *mut GMimeStream;
    pub fn g_mime_stream_gio_new_with_bounds(file: *mut gio::GFile, start: i64, end: i64) -> *mut GMimeStream;
    pub fn g_mime_stream_gio_get_owner(stream: *mut GMimeStreamGIO) -> gboolean;
    pub fn g_mime_stream_gio_set_owner(stream: *mut GMimeStreamGIO, owner: gboolean);

    //=========================================================================
    // GMimeStreamMem
    //=========================================================================
    pub fn g_mime_stream_mem_get_type() -> GType;
    pub fn g_mime_stream_mem_new() -> *mut GMimeStream;
    pub fn g_mime_stream_mem_new_with_buffer(buffer: *mut u8, len: size_t) -> *mut GMimeStream;
    pub fn g_mime_stream_mem_new_with_byte_array(array: *mut glib::GByteArray) -> *mut GMimeStream;
    pub fn g_mime_stream_mem_get_byte_array(mem: *mut GMimeStreamMem) -> *mut glib::GByteArray;
    pub fn g_mime_stream_mem_get_owner(mem: *mut GMimeStreamMem) -> gboolean;
    pub fn g_mime_stream_mem_set_byte_array(mem: *mut GMimeStreamMem, array: *mut glib::GByteArray);
    pub fn g_mime_stream_mem_set_owner(mem: *mut GMimeStreamMem, owner: gboolean);

    //=========================================================================
    // GMimeStreamMmap
    //=========================================================================
    pub fn g_mime_stream_mmap_get_type() -> GType;
    pub fn g_mime_stream_mmap_new(fd: c_int, prot: c_int, flags: c_int) -> *mut GMimeStream;
    pub fn g_mime_stream_mmap_new_with_bounds(fd: c_int, prot: c_int, flags: c_int, start: i64, end: i64) -> *mut GMimeStream;
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_stream_mmap_get_owner(stream: *mut GMimeStreamMmap) -> gboolean;
    #[cfg(any(feature = "v3_2", feature = "dox"))]
    pub fn g_mime_stream_mmap_set_owner(stream: *mut GMimeStreamMmap, owner: gboolean);

    //=========================================================================
    // GMimeStreamNull
    //=========================================================================
    pub fn g_mime_stream_null_get_type() -> GType;
    pub fn g_mime_stream_null_new() -> *mut GMimeStream;
    pub fn g_mime_stream_null_get_count_newlines(stream: *mut GMimeStreamNull) -> gboolean;
    pub fn g_mime_stream_null_set_count_newlines(stream: *mut GMimeStreamNull, count: gboolean);

    //=========================================================================
    // GMimeStreamPipe
    //=========================================================================
    pub fn g_mime_stream_pipe_get_type() -> GType;
    pub fn g_mime_stream_pipe_new(fd: c_int) -> *mut GMimeStream;
    pub fn g_mime_stream_pipe_get_owner(stream: *mut GMimeStreamPipe) -> gboolean;
    pub fn g_mime_stream_pipe_set_owner(stream: *mut GMimeStreamPipe, owner: gboolean);

    //=========================================================================
    // GMimeTextPart
    //=========================================================================
    pub fn g_mime_text_part_get_type() -> GType;
    pub fn g_mime_text_part_new() -> *mut GMimeTextPart;
    pub fn g_mime_text_part_new_with_subtype(subtype: *const c_char) -> *mut GMimeTextPart;
    pub fn g_mime_text_part_get_charset(mime_part: *mut GMimeTextPart) -> *const c_char;
    pub fn g_mime_text_part_get_text(mime_part: *mut GMimeTextPart) -> *mut c_char;
    pub fn g_mime_text_part_set_charset(mime_part: *mut GMimeTextPart, charset: *const c_char);
    pub fn g_mime_text_part_set_text(mime_part: *mut GMimeTextPart, text: *const c_char);

    //=========================================================================
    // InternetAddress
    //=========================================================================
    pub fn internet_address_get_type() -> GType;
    pub fn internet_address_get_charset(ia: *mut InternetAddress) -> *const c_char;
    pub fn internet_address_get_name(ia: *mut InternetAddress) -> *const c_char;
    pub fn internet_address_set_charset(ia: *mut InternetAddress, charset: *const c_char);
    pub fn internet_address_set_name(ia: *mut InternetAddress, name: *const c_char);
    pub fn internet_address_to_string(ia: *mut InternetAddress, options: *mut GMimeFormatOptions, encode: gboolean) -> *mut c_char;

    //=========================================================================
    // InternetAddressGroup
    //=========================================================================
    pub fn internet_address_group_get_type() -> GType;
    pub fn internet_address_group_new(name: *const c_char) -> *mut InternetAddress;
    pub fn internet_address_group_add_member(group: *mut InternetAddressGroup, member: *mut InternetAddress) -> c_int;
    pub fn internet_address_group_get_members(group: *mut InternetAddressGroup) -> *mut InternetAddressList;
    pub fn internet_address_group_set_members(group: *mut InternetAddressGroup, members: *mut InternetAddressList);

    //=========================================================================
    // InternetAddressList
    //=========================================================================
    pub fn internet_address_list_get_type() -> GType;
    pub fn internet_address_list_new() -> *mut InternetAddressList;
    pub fn internet_address_list_parse(options: *mut GMimeParserOptions, str: *const c_char) -> *mut InternetAddressList;
    pub fn internet_address_list_add(list: *mut InternetAddressList, ia: *mut InternetAddress) -> c_int;
    pub fn internet_address_list_append(list: *mut InternetAddressList, append: *mut InternetAddressList);
    pub fn internet_address_list_clear(list: *mut InternetAddressList);
    pub fn internet_address_list_contains(list: *mut InternetAddressList, ia: *mut InternetAddress) -> gboolean;
    pub fn internet_address_list_encode(list: *mut InternetAddressList, options: *mut GMimeFormatOptions, str: *mut glib::GString);
    pub fn internet_address_list_get_address(list: *mut InternetAddressList, index: c_int) -> *mut InternetAddress;
    pub fn internet_address_list_index_of(list: *mut InternetAddressList, ia: *mut InternetAddress) -> c_int;
    pub fn internet_address_list_insert(list: *mut InternetAddressList, index: c_int, ia: *mut InternetAddress);
    pub fn internet_address_list_length(list: *mut InternetAddressList) -> c_int;
    pub fn internet_address_list_prepend(list: *mut InternetAddressList, prepend: *mut InternetAddressList);
    pub fn internet_address_list_remove(list: *mut InternetAddressList, ia: *mut InternetAddress) -> gboolean;
    pub fn internet_address_list_remove_at(list: *mut InternetAddressList, index: c_int) -> gboolean;
    pub fn internet_address_list_set_address(list: *mut InternetAddressList, index: c_int, ia: *mut InternetAddress);
    pub fn internet_address_list_to_string(list: *mut InternetAddressList, options: *mut GMimeFormatOptions, encode: gboolean) -> *mut c_char;

    //=========================================================================
    // InternetAddressMailbox
    //=========================================================================
    pub fn internet_address_mailbox_get_type() -> GType;
    pub fn internet_address_mailbox_new(name: *const c_char, addr: *const c_char) -> *mut InternetAddress;
    pub fn internet_address_mailbox_get_addr(mailbox: *mut InternetAddressMailbox) -> *const c_char;
    pub fn internet_address_mailbox_get_idn_addr(mailbox: *mut InternetAddressMailbox) -> *const c_char;
    pub fn internet_address_mailbox_set_addr(mailbox: *mut InternetAddressMailbox, addr: *const c_char);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn g_mime_check_version(major: c_uint, minor: c_uint, micro: c_uint) -> gboolean;
    pub fn g_mime_content_encoding_from_string(str: *const c_char) -> GMimeContentEncoding;
    pub fn g_mime_content_encoding_to_string(encoding: GMimeContentEncoding) -> *const c_char;
    pub fn g_mime_iconv_close(cd: iconv_t) -> c_int;
    pub fn g_mime_iconv_locale_to_utf8(str: *const c_char) -> *mut c_char;
    pub fn g_mime_iconv_locale_to_utf8_length(str: *const c_char, n: size_t) -> *mut c_char;
    pub fn g_mime_iconv_open(to: *const c_char, from: *const c_char) -> iconv_t;
    pub fn g_mime_iconv_strdup(cd: iconv_t, str: *const c_char) -> *mut c_char;
    pub fn g_mime_iconv_strndup(cd: iconv_t, str: *const c_char, n: size_t) -> *mut c_char;
    pub fn g_mime_iconv_utf8_to_locale(str: *const c_char) -> *mut c_char;
    pub fn g_mime_iconv_utf8_to_locale_length(str: *const c_char, n: size_t) -> *mut c_char;
    pub fn g_mime_init();
    pub fn g_mime_locale_charset() -> *const c_char;
    pub fn g_mime_locale_language() -> *const c_char;
    pub fn g_mime_shutdown();
    pub fn g_mime_utils_best_encoding(text: *mut u8, len: size_t) -> GMimeContentEncoding;
    pub fn g_mime_utils_decode_8bit(options: *mut GMimeParserOptions, text: *mut u8, len: size_t) -> *mut c_char;
    pub fn g_mime_utils_decode_message_id(message_id: *const c_char) -> *mut c_char;
    pub fn g_mime_utils_generate_message_id(fqdn: *const c_char) -> *mut c_char;
    pub fn g_mime_utils_header_decode_date(str: *const c_char) -> *mut glib::GDateTime;
    pub fn g_mime_utils_header_decode_phrase(options: *mut GMimeParserOptions, phrase: *const c_char) -> *mut c_char;
    pub fn g_mime_utils_header_decode_text(options: *mut GMimeParserOptions, text: *const c_char) -> *mut c_char;
    pub fn g_mime_utils_header_encode_phrase(options: *mut GMimeFormatOptions, phrase: *const c_char, charset: *const c_char) -> *mut c_char;
    pub fn g_mime_utils_header_encode_text(options: *mut GMimeFormatOptions, text: *const c_char, charset: *const c_char) -> *mut c_char;
    pub fn g_mime_utils_header_format_date(date: *mut glib::GDateTime) -> *mut c_char;
    pub fn g_mime_utils_header_printf(options: *mut GMimeParserOptions, format: *mut GMimeFormatOptions, text: *const c_char, ...) -> *mut c_char;
    pub fn g_mime_utils_header_unfold(value: *const c_char) -> *mut c_char;
    pub fn g_mime_utils_quote_string(str: *const c_char) -> *mut c_char;
    pub fn g_mime_utils_structured_header_fold(options: *mut GMimeParserOptions, format: *mut GMimeFormatOptions, header: *const c_char) -> *mut c_char;
    pub fn g_mime_utils_text_is_8bit(text: *mut u8, len: size_t) -> gboolean;
    pub fn g_mime_utils_unquote_string(str: *mut c_char);
    pub fn g_mime_utils_unstructured_header_fold(options: *mut GMimeParserOptions, format: *mut GMimeFormatOptions, header: *const c_char) -> *mut c_char;
    pub fn g_mime_ydecode_step(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, pcrc: *mut u32, crc: *mut u32) -> size_t;
    pub fn g_mime_yencode_close(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, pcrc: *mut u32, crc: *mut u32) -> size_t;
    pub fn g_mime_yencode_step(inbuf: *const u8, inlen: size_t, outbuf: *mut u8, state: *mut c_int, pcrc: *mut u32, crc: *mut u32) -> size_t;

}
